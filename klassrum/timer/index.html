<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Klassrumstimer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&display=swap" />
  <style>
    :root {
      --bg: #f4f4f4;
      --white: #ffffff;
      --primary: #40534C; /* Primärfärg */
      --effect: #677D6A;  /* Effektfärg */
      --dark: #1A3636;
      --text: #644117;
      --subtle: #D6BD98;
      --placeholder: #677D6A; /* Standard placeholder-färg */
      --textarea: #FCF8F4;
      
      /* Klockans färger */
      --clock-border: #1A3636;
      --clock-bg: #FCF8F4;
      --clock-digit: #1A3636;
      --clock-hand: #2C3E50;
      --clock-second-hand: #A44434;
      --clock-border-width: 0.05;
      
      /* Timer-specifika variabler */
      --timer-font-family: sans-serif;
      --timer-font-size: 52px;
      --timer-font-weight: 400;
      --timer-font-color: var(--dark);
      --timer-bg: #FCF8F4;
      --timer-border: #1A3636;
      --timer-progress-color: #F7E7CE;
      --timer-text-shadow: 0px 0px 2px rgba(250, 250, 250, 0.9);
    }
    
    * { box-sizing: border-box; }
    
    body {
      font-family: 'Source Serif Pro', serif;
      margin: 0;
      padding: 0;
      background-color: var(--bg);
    }
    
    .container {
      max-width: 740px;
      margin: 20px auto;
      padding: 20px;
      background-color: var(--white);
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    
    h1 {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      font-size: 24px;
      color: var(--white);
      background-color: var(--primary);
      border-radius: 8px 8px 0 0;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .inforuta {
      margin-top: 0;
      font-size: 15px;
      color: var(--text);
      background-color: var(--subtle);
      border-radius: 0 0 8px 8px;
      padding: 10px 20px;
      margin-bottom: 15px;
    }
    
    .game-area {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      background-color: var(--effect);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid var(--primary);
    }
    
    .box {
      flex: 1 1 45%;
      background-color: var(--primary);
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: var(--dark);
      position: relative;
    }
    
    /* Timer och klockelement */
    #timer-container {
      position: relative;
      width: 250px;
      height: 250px;
      margin: 0 auto;
    }
    
    #timer-canvas {
      display: block;
      margin: 0 auto;
    }
    
    #timer-info {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    #timer-display {
      font-size: var(--timer-font-size);
      font-family: var(--timer-font-family);
      font-weight: var(--timer-font-weight);
      color: var(--timer-font-color);
      text-shadow: var(--timer-text-shadow);
      outline: none;
      cursor: text;
      height: 52px;
      line-height: 52px;
    }
    
    #timer-controls {
      display: flex;
      flex-direction: column;
      gap: 0px;
      height: 52px;
      margin-top: 9px;
    }
    
    #timer-controls button {
      padding: 0;
      margin: 0;
      background: none;
      border: none;
      cursor: pointer;
      height: calc((52px - 10px) / 2);
    }
    
    .material-icons {
      color: #40534C;
    }
    
    #clock-box {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    #clock-box canvas {
      display: block;
      width: 250px;
      height: 250px;
    }
    
    /* Meddelanderader */
    #message-rows {
      flex: 1 1 100%;
      margin-top: 0;
      position: relative;
    }
    
    /* Rader utan extra sidomarginaler */
    .message-row {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      margin: 0 0 10px 0;
      position: relative;
      padding: 0;
    }
    
    .message-box {
      flex: 1;
      background-color: var(--primary);
      border-radius: 5px;
      padding: 10px 40px 10px 10px;
      position: relative;
      text-align: left;
      min-height: 40px;
      color: #ffffff;
    }
    
    /* Styling för ny rad */
    .message-box.new-box {
      border: 2px dashed var(--primary);
      background-color: var(--effect);
    }
    
    /* Placeholder-styling */
    .message-cell:empty:not(:focus):before {
      content: attr(data-placeholder);
      color: var(--placeholder);
      display: block;
    }
    .message-box.new-box .message-cell:empty:not(:focus):before {
      color: #ffffff;
    }
    
    .message-cell {
      outline: none;
    }
    
    /* Textstorlekskontroller */
    .text-size-controls {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      gap: 5px;
    }
    .text-size-controls .material-icons {
      cursor: pointer;
      user-select: none;
      font-size: 16px;
      color: #ffffff;
    }
    
    /* Kolumnkontroller – dolda som standard, visas vid hover */
    .message-controls {
      display: none;
      flex-direction: column;
      justify-content: center;
      gap: 5px;
      cursor: pointer;
      align-self: center;
    }
    .message-row:hover .message-controls {
      display: flex;
    }
    
    /* Vänsterpil för att ta bort rad – dolda som standard */
    .row-btn {
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      cursor: pointer;
      display: none;
    }
    .message-row:hover .row-btn {
      display: block;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Klassrumstimer</h1>
    <p class="inforuta">
      En enkel timer och klocka för visning på projektor under lektioner. Det går även att visa annan information som provkoder eller instruktioner.
    </p>
    <div class="game-area">
      <!-- Timer och klocka -->
      <div id="timer-box" class="box">
        <div id="timer-container">
          <canvas id="timer-canvas" width="250" height="250"></canvas>
          <div id="timer-info">
            <span id="timer-display" contentEditable="true">60:00</span>
            <div id="timer-controls">
              <button id="toggle-btn"><i class="material-icons">play_arrow</i></button>
              <button id="stop-btn"><i class="material-icons">stop</i></button>
            </div>
          </div>
        </div>
      </div>
      <div id="clock-box" class="box">
        <canvas id="clock-canvas" width="250" height="250"></canvas>
      </div>
      <!-- Meddelanderader -->
      <div id="message-rows"></div>
    </div>
  </div>
  <script>
    /* ---------------- Timer och klocka ---------------- */
    function parseTimeString(timeStr) {
      const parts = timeStr.split(':');
      if (parts.length === 2) {
        const minutes = parseInt(parts[0], 10);
        const seconds = parseInt(parts[1], 10);
        if (!isNaN(minutes) && !isNaN(seconds)) {
          return minutes * 60 + seconds;
        }
      }
      return null;
    }
    
    function formatTime(totalSeconds) {
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return (minutes < 10 ? "0" + minutes : minutes) + ":" +
             (seconds < 10 ? "0" + seconds : seconds);
    }
    
    const timerDisplayElem = document.getElementById("timer-display");
    let timerDuration = parseTimeString(timerDisplayElem.textContent) || 3600;
    let timeLeft = timerDuration;
    let timerInterval = null;
    let isTimerRunning = false;
    
    function updateTimerDisplay() {
      timerDisplayElem.textContent = formatTime(timeLeft);
      updateTimerCanvas();
    }
    
    timerDisplayElem.addEventListener("blur", function() {
      const newTime = parseTimeString(timerDisplayElem.textContent);
      if (newTime !== null && newTime > 0) {
        timerDuration = newTime;
        timeLeft = timerDuration;
        updateTimerDisplay();
      } else {
        timerDisplayElem.textContent = formatTime(timeLeft);
      }
    });
    
    document.getElementById("toggle-btn").addEventListener("click", function() {
      const toggleBtnIcon = this.querySelector("i");
      if (!isTimerRunning) {
        timerDisplayElem.contentEditable = false;
        timerInterval = setInterval(function() {
          if (timeLeft > 0) {
            timeLeft--;
            updateTimerDisplay();
          } else {
            clearInterval(timerInterval);
            isTimerRunning = false;
            timerDisplayElem.contentEditable = true;
            toggleBtnIcon.textContent = "play_arrow";
          }
        }, 1000);
        isTimerRunning = true;
        toggleBtnIcon.textContent = "pause";
      } else {
        clearInterval(timerInterval);
        isTimerRunning = false;
        timerDisplayElem.contentEditable = true;
        toggleBtnIcon.textContent = "play_arrow";
      }
    });
    
    document.getElementById("stop-btn").addEventListener("click", function() {
      clearInterval(timerInterval);
      isTimerRunning = false;
      timeLeft = timerDuration;
      updateTimerDisplay();
      timerDisplayElem.contentEditable = true;
      document.querySelector("#toggle-btn i").textContent = "play_arrow";
    });
    
    updateTimerDisplay();
    
    function updateTimerCanvas() {
      const canvas = document.getElementById("timer-canvas");
      const ctx = canvas.getContext("2d");
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) * 0.90;
      
      const rootStyles = getComputedStyle(document.documentElement);
      const timerBg = rootStyles.getPropertyValue('--timer-bg').trim();
      const timerBorder = rootStyles.getPropertyValue('--timer-border').trim();
      const borderRatio = parseFloat(rootStyles.getPropertyValue('--clock-border-width')) || 0.05;
      const borderThickness = radius * borderRatio;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.fillStyle = timerBg;
      ctx.fill();
      
      let progress = (timerDuration - timeLeft) / timerDuration;
      let startAngle = -Math.PI / 2;
      let endAngle = startAngle + progress * 2 * Math.PI;
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
      ctx.closePath();
      ctx.fillStyle = rootStyles.getPropertyValue('--timer-progress-color').trim();
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.strokeStyle = timerBorder;
      ctx.lineWidth = borderThickness;
      ctx.stroke();
    }
    
    function drawClock() {
      const canvas = document.getElementById("clock-canvas");
      const ctx = canvas.getContext("2d");
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) * 0.90;
      
      const rootStyles = getComputedStyle(document.documentElement);
      const clockBg = rootStyles.getPropertyValue('--clock-bg').trim();
      const clockBorder = rootStyles.getPropertyValue('--clock-border').trim();
      const clockBorderWidth = parseFloat(rootStyles.getPropertyValue('--clock-border-width')) || 0.05;
      const clockDigit = rootStyles.getPropertyValue('--clock-digit').trim();
      const clockHand = rootStyles.getPropertyValue('--clock-hand').trim();
      const clockSecondHand = rootStyles.getPropertyValue('--clock-second-hand').trim();
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.fillStyle = clockBg;
      ctx.fill();
      ctx.strokeStyle = clockBorder;
      ctx.lineWidth = radius * clockBorderWidth;
      ctx.stroke();
      
      ctx.fillStyle = clockDigit;
      ctx.font = (radius * 0.15) + "px sans-serif";
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";
      for (let num = 1; num <= 12; num++) {
        let ang = num * Math.PI / 6;
        let numX = centerX + radius * 0.75 * Math.cos(ang - Math.PI/2);
        let numY = centerY + radius * 0.75 * Math.sin(ang - Math.PI/2);
        ctx.fillText(num.toString(), numX, numY);
      }
      
      let now = new Date();
      let hour = now.getHours() % 12;
      let minute = now.getMinutes();
      let second = now.getSeconds();
      let hourAngle = (hour * Math.PI / 6) + (minute * Math.PI / 360) + (second * Math.PI / 21600);
      drawHand(ctx, centerX, centerY, hourAngle, radius * 0.5, radius * 0.07, clockHand);
      let minuteAngle = (minute * Math.PI / 30) + (second * Math.PI / 1800);
      drawHand(ctx, centerX, centerY, minuteAngle, radius * 0.7, radius * 0.05, clockHand);
      let secondAngle = second * Math.PI / 30;
      drawHand(ctx, centerX, centerY, secondAngle, radius * 0.8, radius * 0.02, clockSecondHand);
    }
    
    function drawHand(ctx, x, y, pos, length, width, color) {
      ctx.beginPath();
      ctx.lineWidth = width;
      ctx.lineCap = "round";
      ctx.strokeStyle = color || "#40534C";
      ctx.moveTo(x, y);
      ctx.lineTo(x + length * Math.cos(pos - Math.PI/2), y + length * Math.sin(pos - Math.PI/2));
      ctx.stroke();
    }
    
    setInterval(drawClock, 1000);
    drawClock();
    
    /* ---------------- Meddelanderader med dynamiska kontroller ---------------- */
    const messageRowsContainer = document.getElementById('message-rows');
    
    // Skapa en ny meddelanderad.
    // isNew === true markerar "ny rad" med specialstil (där placeholdertexten har en annan färg).
    function createMessageRow(isNew = false) {
      const row = document.createElement('div');
      row.classList.add('message-row');
      
      // Om raden inte är ny, lägg till en vänsterpil för att ta bort hela raden.
      if (!isNew) {
        const rowBtn = document.createElement('span');
        rowBtn.classList.add('material-icons', 'row-btn');
        rowBtn.textContent = "arrow_left";
        rowBtn.setAttribute("title", "Ta bort rad");
        rowBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          messageRowsContainer.removeChild(row);
        });
        row.appendChild(rowBtn);
      }
      
      // Skapa meddelanderutan
      const box = document.createElement('div');
      box.classList.add('message-box');
      if (isNew) {
        box.classList.add('new-box');
      }
      
      const cell = document.createElement('div');
      cell.classList.add('message-cell');
      cell.setAttribute("contenteditable", "true");
      cell.setAttribute("data-placeholder", isNew ? "Skriv här för att skapa en ny rad." : "Skriv meddelande här...");
      cell.innerHTML = "";
      
      const textSizeControls = document.createElement('div');
      textSizeControls.classList.add('text-size-controls');
      
      const decreaseBtn = document.createElement('span');
      decreaseBtn.classList.add('material-icons', 'decrease-text');
      decreaseBtn.setAttribute("contenteditable", "false");
      decreaseBtn.textContent = "remove";
      
      const increaseBtn = document.createElement('span');
      increaseBtn.classList.add('material-icons', 'increase-text');
      increaseBtn.setAttribute("contenteditable", "false");
      increaseBtn.textContent = "add";
      
      textSizeControls.appendChild(decreaseBtn);
      textSizeControls.appendChild(increaseBtn);
      
      box.appendChild(cell);
      box.appendChild(textSizeControls);
      
      // Skapa kontroll för kolumn (högerpil)
      const controls = document.createElement('div');
      controls.classList.add('message-controls');
      
      const columnBtn = document.createElement('span');
      columnBtn.classList.add('material-icons', 'column-btn');
      columnBtn.setAttribute("title", "Lägg till kolumn");
      columnBtn.textContent = "arrow_right";
      
      controls.appendChild(columnBtn);
      
      row.appendChild(box);
      row.appendChild(controls);
      
      initMessageBox(box);
      
      // När man börjar skriva i den sista (nya) raden tas "new"-stilen bort och en ny rad läggs till.
      cell.addEventListener('input', function() {
        if (row === messageRowsContainer.lastElementChild && box.classList.contains('new-box') && cell.textContent.trim() !== "") {
          box.classList.remove('new-box');
          cell.setAttribute("data-placeholder", "Skriv meddelande här...");
          messageRowsContainer.appendChild(createMessageRow(true));
        }
      });
      
      // Om raden bara har en ruta, tas den bort (om rutan är tom) vid blur (förutom den sista, nya raden)
      cell.addEventListener('blur', function() {
        if (row !== messageRowsContainer.lastElementChild &&
            row.querySelectorAll('.message-box').length === 1 &&
            cell.textContent.trim() === "") {
          messageRowsContainer.removeChild(row);
        }
      });
      
      return row;
    }
    
    // Initiera med en första rad (ny rad)
    messageRowsContainer.appendChild(createMessageRow(true));
    
    // Initiera textstorlekskontroller
    function initMessageBox(messageBox) {
      const messageCell = messageBox.querySelector('.message-cell');
      messageCell.dataset.fontSize = "16";
      messageCell.addEventListener('input', function() {
        if (messageCell.textContent.trim() === "") {
          messageCell.innerHTML = "";
        }
      });
      const increaseBtn = messageBox.querySelector('.increase-text');
      const decreaseBtn = messageBox.querySelector('.decrease-text');
      
      increaseBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        let fontSize = parseInt(messageCell.dataset.fontSize, 10);
        fontSize += 2;
        messageCell.dataset.fontSize = fontSize;
        messageCell.style.fontSize = fontSize + "px";
      });
      
      decreaseBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        let fontSize = parseInt(messageCell.dataset.fontSize, 10);
        if (fontSize > 6) {
          fontSize -= 2;
          messageCell.dataset.fontSize = fontSize;
          messageCell.style.fontSize = fontSize + "px";
        }
      });
    }
    
    // Eventdelegation för kolumnknappen:
    messageRowsContainer.addEventListener('click', function(e) {
      if (e.target.classList.contains('column-btn')) {
        const row = e.target.closest('.message-row');
        const boxes = row.querySelectorAll('.message-box');
        if (boxes.length === 1) {
          // Kontrollera att cellen inte är tom innan vi lägger till en kolumn
          const cell = boxes[0].querySelector('.message-cell');
          if (cell.textContent.trim() === "") {
            return;
          }
          // Lägg till en extra kolumn
          const newBox = boxes[0].cloneNode(true);
          const newCell = newBox.querySelector('.message-cell');
          newCell.innerHTML = "";
          newCell.dataset.fontSize = "16";
          newBox.classList.remove('new-box');
          newCell.setAttribute("data-placeholder", "Skriv meddelande här...");
          initMessageBox(newBox);
          row.insertBefore(newBox, row.querySelector('.message-controls'));
          // Ändra ikonen till en vänsterpekande pil
          e.target.textContent = "arrow_left";
          e.target.setAttribute("title", "Ta bort kolumn");
        } else if (boxes.length === 2) {
          // Ta bort den extra kolumnen
          row.removeChild(row.querySelectorAll('.message-box')[1]);
          // Återställ ikonen till högerpil
          e.target.textContent = "arrow_right";
          e.target.setAttribute("title", "Lägg till kolumn");
        }
      }
    });
  </script>
</body>
</html>
