<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Klassrumstimer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&display=swap" />
  <style>
    :root {
      --bg: #f4f4f4;
      --white: #ffffff;
      --primary: #40534C;
      --effect: #677D6A;
      --dark: #1A3636;
      --text: #644117;
      --subtle: #D6BD98;
      --placeholder: #677D6A;
      --textarea: #FCF8F4;
      
      /* Klockans färger */
      --clock-border: #1A3636;
      --clock-bg: #FCF8F4;
      --clock-digit: #1A3636;
      --clock-hand: #2C3E50;
      --clock-second-hand: #A44434;
      --clock-border-width: 0.05;
      
      /* Timer */
      --timer-font-family: sans-serif;
      --timer-font-size: 52px;
      --timer-font-weight: 400;
      --timer-font-color: var(--dark);
      --timer-bg: #FCF8F4;
      --timer-border: #1A3636;
      --timer-progress-color: #F7E7CE;
      --timer-text-shadow: 0px 0px 2px rgba(250, 250, 250, 0.9);

      /* Meddelande-textstorlekar */
      --msg-text-size-small: 16px;
      --msg-text-size-medium: 20px;
      --msg-text-size-large: 24px;
    }
    
    * { box-sizing: border-box; }
    
    body {
      font-family: 'Source Serif Pro', serif;
      margin: 0;
      padding: 0;
      background-color: var(--bg);
    }
    
    .container {
      max-width: 740px;
      margin: 20px auto;
      padding: 20px;
      background-color: var(--white);
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    
    h1 {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      font-size: 24px;
      color: var(--white);
      background-color: var(--primary);
      border-radius: 8px 8px 0 0;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .inforuta {
      margin-top: 0;
      font-size: 15px;
      color: var(--text);
      background-color: var(--subtle);
      border-radius: 0 0 8px 8px;
      padding: 10px 20px;
      margin-bottom: 15px;
    }
    
    .game-area {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      background-color: var(--effect);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid var(--primary);
    }
    
    .box {
      flex: 1 1 45%;
      background-color: var(--primary);
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: var(--dark);
      position: relative;
    }
    
    /* Timer och klockelement */
    #timer-container {
      position: relative;
      width: 250px;
      height: 250px;
      margin: 0 auto;
    }
    
    #timer-canvas { display: block; margin: 0 auto; }
    
    #timer-info {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    #timer-display {
      font-size: var(--timer-font-size);
      font-family: var(--timer-font-family);
      font-weight: var(--timer-font-weight);
      color: var(--timer-font-color);
      text-shadow: var(--timer-text-shadow);
      outline: none;
      cursor: text;
      height: 52px;
      line-height: 52px;
    }
    
    #timer-controls {
      display: flex;
      flex-direction: column;
      gap: 0;
      height: 52px;
      margin-top: 9px;
    }
    
    #timer-controls button {
      padding: 0;
      margin: 0;
      background: none;
      border: none;
      cursor: pointer;
      height: calc((52px - 10px) / 2);
    }
    
    .material-icons { color: #40534C; }
    
    #clock-box {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    #clock-box canvas {
      display: block;
      width: 250px;
      height: 250px;
    }
    
    /* Meddelanderader */
    #message-rows {
      flex: 1 1 100%;
      margin-top: 0;
    }
    
    .message-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0 0 10px 0;
    }
    /* Sista (nya) raden ska inte ha extra marginal nedanför */
    .message-row:last-child { margin-bottom: 0; }
    
    .message-box {
      flex: 1;
      background-color: var(--primary);
      border-radius: 5px;
      padding: 10px;
      text-align: center;
      min-height: 40px;
      color: #ffffff;
      font-family: sans-serif;
    }
    
    .message-box.new-box {
      border: 1px dashed var(--primary);
      background-color: var(--effect);
    }
    
    .message-cell:empty:not(:focus):before {
      content: attr(data-placeholder);
      color: var(--placeholder);
      display: block;
    }
    .message-box.new-box .message-cell:empty:not(:focus):before {
      color: var(--primary);
    }
    
    .message-cell { outline: none; }
    
    /* Dolda kontroller visas som sista flexbarnet i raden */
    .row-controls {
      margin-left: auto;
      display: none;
      gap: 10px;
      align-items: center;
    }
    .message-row:hover .row-controls { display: flex; }
    
    .text-size-controls { display: flex; gap: 5px; }
    
    .text-size-btn {
      cursor: pointer;
      user-select: none;
      color: #ffffff;
    }
    
    .message-controls {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 5px;
      cursor: pointer;
      align-self: center;
    }
    
    .row-btn {
      cursor: pointer;
      display: none;
    }
    .message-row:hover .row-btn { display: block; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Klassrumstimer för projektor</h1>
    <p class="inforuta">
      En enkel timer och klocka för visning på projektor under lektioner eller prov. Ändra timern genom att skriva rätt i rutan när timern är avstängd. Utöver den funktionaliteten går det även att visa annan information såsom provkoder eller instruktioner för den uppgift som de ska arbeta med.
    </p>
    <div class="game-area">
      <!-- Timer och klocka -->
      <div id="timer-box" class="box">
        <div id="timer-container">
          <canvas id="timer-canvas" width="250" height="250"></canvas>
          <div id="timer-info">
            <span id="timer-display" contentEditable="true">60:00</span>
            <div id="timer-controls">
              <button id="toggle-btn"><i class="material-icons">play_arrow</i></button>
              <button id="stop-btn"><i class="material-icons">stop</i></button>
            </div>
          </div>
        </div>
      </div>
      <div id="clock-box" class="box">
        <canvas id="clock-canvas" width="250" height="250"></canvas>
      </div>
      <!-- Meddelanderader -->
      <div id="message-rows"></div>
    </div>
  </div>
  <script>
    /* ---------------- Timer och klocka ---------------- */
    function parseTimeString(timeStr) {
      const parts = timeStr.split(':');
      if (parts.length === 2) {
        const minutes = parseInt(parts[0], 10);
        const seconds = parseInt(parts[1], 10);
        if (!isNaN(minutes) && !isNaN(seconds)) {
          return minutes * 60 + seconds;
        }
      }
      return null;
    }
    
    function formatTime(totalSeconds) {
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return (minutes < 10 ? "0" + minutes : minutes) + ":" +
             (seconds < 10 ? "0" + seconds : seconds);
    }
    
    const timerDisplayElem = document.getElementById("timer-display");
    let timerDuration = parseTimeString(timerDisplayElem.textContent) || 3600;
    let timeLeft = timerDuration;
    let timerInterval = null;
    let isTimerRunning = false;
    
    function updateTimerDisplay() {
      timerDisplayElem.textContent = formatTime(timeLeft);
      updateTimerCanvas();
    }
    
    timerDisplayElem.addEventListener("blur", function() {
      const newTime = parseTimeString(timerDisplayElem.textContent);
      if (newTime !== null && newTime > 0) {
        timerDuration = newTime;
        timeLeft = timerDuration;
        updateTimerDisplay();
      } else {
        timerDisplayElem.textContent = formatTime(timeLeft);
      }
    });
    
    document.getElementById("toggle-btn").addEventListener("click", function() {
      const toggleBtnIcon = this.querySelector("i");
      if (!isTimerRunning) {
        timerDisplayElem.contentEditable = false;
        timerInterval = setInterval(function() {
          if (timeLeft > 0) {
            timeLeft--;
            updateTimerDisplay();
          } else {
            clearInterval(timerInterval);
            isTimerRunning = false;
            timerDisplayElem.contentEditable = true;
            toggleBtnIcon.textContent = "play_arrow";
          }
        }, 1000);
        isTimerRunning = true;
        toggleBtnIcon.textContent = "pause";
      } else {
        clearInterval(timerInterval);
        isTimerRunning = false;
        timerDisplayElem.contentEditable = true;
        toggleBtnIcon.textContent = "play_arrow";
      }
    });
    
    document.getElementById("stop-btn").addEventListener("click", function() {
      clearInterval(timerInterval);
      isTimerRunning = false;
      timeLeft = timerDuration;
      updateTimerDisplay();
      timerDisplayElem.contentEditable = true;
      document.querySelector("#toggle-btn i").textContent = "play_arrow";
    });
    
    updateTimerDisplay();
    
    function updateTimerCanvas() {
      const canvas = document.getElementById("timer-canvas");
      const ctx = canvas.getContext("2d");
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) * 0.90;
      
      const rootStyles = getComputedStyle(document.documentElement);
      const timerBg = rootStyles.getPropertyValue('--timer-bg').trim();
      const timerBorder = rootStyles.getPropertyValue('--timer-border').trim();
      const borderRatio = parseFloat(rootStyles.getPropertyValue('--clock-border-width')) || 0.05;
      const borderThickness = radius * borderRatio;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.fillStyle = timerBg;
      ctx.fill();
      
      let progress = (timerDuration - timeLeft) / timerDuration;
      let startAngle = -Math.PI / 2;
      let endAngle = startAngle + progress * 2 * Math.PI;
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
      ctx.closePath();
      ctx.fillStyle = rootStyles.getPropertyValue('--timer-progress-color').trim();
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.strokeStyle = timerBorder;
      ctx.lineWidth = borderThickness;
      ctx.stroke();
    }
    
    function drawClock() {
      const canvas = document.getElementById("clock-canvas");
      const ctx = canvas.getContext("2d");
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) * 0.90;
      
      const rootStyles = getComputedStyle(document.documentElement);
      const clockBg = rootStyles.getPropertyValue('--clock-bg').trim();
      const clockBorder = rootStyles.getPropertyValue('--clock-border').trim();
      const clockBorderWidth = parseFloat(rootStyles.getPropertyValue('--clock-border-width')) || 0.05;
      const clockDigit = rootStyles.getPropertyValue('--clock-digit').trim();
      const clockHand = rootStyles.getPropertyValue('--clock-hand').trim();
      const clockSecondHand = rootStyles.getPropertyValue('--clock-second-hand').trim();
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.fillStyle = clockBg;
      ctx.fill();
      ctx.strokeStyle = clockBorder;
      ctx.lineWidth = radius * clockBorderWidth;
      ctx.stroke();
      
      ctx.fillStyle = clockDigit;
      ctx.font = (radius * 0.15) + "px sans-serif";
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";
      for (let num = 1; num <= 12; num++) {
        let ang = num * Math.PI / 6;
        let numX = centerX + radius * 0.75 * Math.cos(ang - Math.PI/2);
        let numY = centerY + radius * 0.75 * Math.sin(ang - Math.PI/2);
        ctx.fillText(num.toString(), numX, numY);
      }
      
      let now = new Date();
      let hour = now.getHours() % 12;
      let minute = now.getMinutes();
      let second = now.getSeconds();
      let hourAngle = (hour * Math.PI / 6) + (minute * Math.PI / 360) + (second * Math.PI / 21600);
      drawHand(ctx, centerX, centerY, hourAngle, radius * 0.5, radius * 0.07, clockHand);
      let minuteAngle = (minute * Math.PI / 30) + (second * Math.PI / 1800);
      drawHand(ctx, centerX, centerY, minuteAngle, radius * 0.7, radius * 0.05, clockHand);
      let secondAngle = second * Math.PI / 30;
      drawHand(ctx, centerX, centerY, secondAngle, radius * 0.8, radius * 0.02, clockSecondHand);
    }
    
    function drawHand(ctx, x, y, pos, length, width, color) {
      ctx.beginPath();
      ctx.lineWidth = width;
      ctx.lineCap = "round";
      ctx.strokeStyle = color || "#40534C";
      ctx.moveTo(x, y);
      ctx.lineTo(x + length * Math.cos(pos - Math.PI/2), y + length * Math.sin(pos - Math.PI/2));
      ctx.stroke();
    }
    
    setInterval(drawClock, 1000);
    drawClock();
    
    /* ---------------- Meddelanderader med dynamiska kontroller ---------------- */
    const messageRowsContainer = document.getElementById('message-rows');
    
    // Initiera eventlyssnare för en cell i en rad
    function initCell(cell, row) {
      cell.addEventListener('input', function() {
        if (row === messageRowsContainer.lastElementChild &&
            cell.parentElement.classList.contains('new-box') &&
            cell.textContent.trim() !== "") {
          cell.parentElement.classList.remove('new-box');
          cell.setAttribute("data-placeholder", "Skriv meddelande här...");
          messageRowsContainer.appendChild(createMessageRow(true));
        }
        if (cell.textContent.trim() === "") {
          cell.innerHTML = "";
        }
      });
      cell.addEventListener('blur', function() {
        if (row !== messageRowsContainer.lastElementChild &&
            row.querySelectorAll('.message-box').length === 1 &&
            cell.textContent.trim() === "") {
          messageRowsContainer.removeChild(row);
        }
      });
    }
    
    function createMessageRow(isNew = false) {
      const row = document.createElement('div');
      row.classList.add('message-row');
      
      // Lägg till en vänsterpil för att ta bort raden (om den inte är ny)
      if (!isNew) {
        const rowBtn = document.createElement('span');
        rowBtn.classList.add('material-icons', 'row-btn');
        rowBtn.textContent = "arrow_left";
        rowBtn.setAttribute("title", "Ta bort rad");
        rowBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          messageRowsContainer.removeChild(row);
        });
        row.appendChild(rowBtn);
      }
      
      // Skapa meddelanderuta/-rutor (första kolumnen)
      const box = document.createElement('div');
      box.classList.add('message-box');
      if (isNew) { box.classList.add('new-box'); }
      
      const cell = document.createElement('div');
      cell.classList.add('message-cell');
      cell.setAttribute("contenteditable", "true");
      cell.setAttribute("data-placeholder", isNew ? "Skriv här för att skapa en ny rad." : "Skriv meddelande här...");
      cell.innerHTML = "";
      box.appendChild(cell);
      row.appendChild(box);
      
      initCell(cell, row);
      
      // Skapa de dolda kontrollerna som ett flexbarn (placerade längst till höger)
      const rowControls = document.createElement('div');
      rowControls.classList.add('row-controls');
      
      // Textstorlekskontroller
      const textSizeControls = document.createElement('div');
      textSizeControls.classList.add('text-size-controls');
      ['small', 'medium', 'large'].forEach(size => {
        const btn = document.createElement('span');
        btn.classList.add('text-size-btn');
        btn.setAttribute("contenteditable", "false");
        btn.setAttribute("data-size", size);
        btn.textContent = "A";
        btn.style.fontSize = `var(--msg-text-size-${size})`;
        textSizeControls.appendChild(btn);
      });
      
      // Kolumnkontroller
      const columnControls = document.createElement('div');
      columnControls.classList.add('message-controls');
      const columnBtn = document.createElement('span');
      columnBtn.classList.add('material-icons', 'column-btn');
      columnBtn.setAttribute("title", "Lägg till kolumn");
      columnBtn.textContent = "arrow_right";
      columnControls.appendChild(columnBtn);
      
      rowControls.appendChild(textSizeControls);
      rowControls.appendChild(columnControls);
      
      row.appendChild(rowControls);
      
      // Händelsehantering för textstorlekskontroller – ändrar fontstorlek på alla celler i raden
      textSizeControls.querySelectorAll('.text-size-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
          e.stopPropagation();
          const size = this.getAttribute('data-size');
          const newSize = getComputedStyle(document.documentElement)
                            .getPropertyValue(`--msg-text-size-${size}`).trim();
          row.querySelectorAll('.message-cell').forEach(cell => {
            cell.style.fontSize = newSize;
            cell.dataset.fontSize = newSize;
          });
        });
      });
      
      // Sätt standardfontstorlek (medium)
      const defaultSize = getComputedStyle(document.documentElement)
                          .getPropertyValue('--msg-text-size-medium').trim();
      cell.style.fontSize = defaultSize;
      cell.dataset.fontSize = defaultSize;
      
      return row;
    }
    
    // Lägg till den första (nya) raden
    messageRowsContainer.appendChild(createMessageRow(true));
    
    // Eventdelegation för kolumnknappen: lägger till eller tar bort en kolumn i raden
    messageRowsContainer.addEventListener('click', function(e) {
      if (e.target.classList.contains('column-btn')) {
        const row = e.target.closest('.message-row');
        const boxes = row.querySelectorAll('.message-box');
        if (boxes.length === 1) {
          const cell = boxes[0].querySelector('.message-cell');
          if (cell.textContent.trim() === "") { return; }
          const newBox = boxes[0].cloneNode(true);
          const newCell = newBox.querySelector('.message-cell');
          newCell.innerHTML = "";
          newCell.dataset.fontSize = getComputedStyle(document.documentElement)
                                      .getPropertyValue('--msg-text-size-medium').trim();
          newBox.classList.remove('new-box');
          newCell.setAttribute("data-placeholder", "Skriv meddelande här...");
          initCell(newCell, row);
          row.insertBefore(newBox, row.querySelector('.row-controls'));
          e.target.textContent = "arrow_left";
          e.target.setAttribute("title", "Ta bort kolumn");
        } else if (boxes.length === 2) {
          row.removeChild(row.querySelectorAll('.message-box')[1]);
          e.target.textContent = "arrow_right";
          e.target.setAttribute("title", "Lägg till kolumn");
        }
      }
    });
  </script>
</body>
</html>
