<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Snake med Q-learning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400&family=Source+Serif+Pro&display=swap" />
  <style>
    :root {
      --bg: #f4f4f4;
      --white: #ffffff;
      --primary: #40534C;
      --cell_mediumgreen: #3CB371;
      --dark: #1A3636;
      --text: #644117;
      --subtle: #D6BD98;
      --effect: #677D6A;
      --placeholder: #B9AFA1;
      --textarea: #FCF8F4;
      --extra_effect: #D98E04;
      --extra_primary: #E0A030;
      --extra_red: #A44434;
      --status_graygreen: #8E9775;
      --status_olivegreen: #5B7052;
      --status_ochreyellow: #D4A76A;
      --status_goldenbrown: #C2955C;
      --status_sienna: #A0522D;
      --status_burntumber: #8A3324;
    }
    
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Source Serif Pro', serif;
      margin: 0;
      padding: 0;
      background-color: var(--bg);
    }
    
    .container {
      width: 740px;
      min-width: 740px;
      background-color: var(--white);
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      padding: 20px;
      margin: 20px auto;
    }
    
    h1 {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      font-size: 24px;
      color: var(--white);
      background-color: var(--primary);
      border-radius: 8px 8px 0 0;
      padding: 10px 20px;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .inforuta {
      margin-top: 0;
      font-size: 15px;
      color: var(--text);
      background-color: var(--subtle);
      border-radius: 0 0 8px 8px;
      padding: 10px 20px;
      margin-bottom: 15px;
    }
    
    /* Inställningar */
    .settings {
      margin-bottom: 15px;
    }
    .settings-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .settings-item {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    label {
      font-family: monospace;
      color: var(--primary);
      font-size: 14px;
      margin-bottom: 5px;
    }
    input[type="number"] {
      background-color: var(--textarea);
      border: 1px solid var(--effect);
      color: var(--dark);
      font-size: 13px;
      padding: 10px;
      border-radius: 5px;
    }
    input[readonly] {
      background-color: #e8e0c8;
    }
    
    /* Separator */
    #separator {
      border-top: 1px dashed var(--dark);
      margin: 20px 0;
    }
    
    /* Layout: spelplan och förklaringsruta sida vid sida */
    .outer-game-container {
      background-color: var(--effect);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid var(--primary);
      margin-bottom: 15px;
    }
    .flex-row {
      display: flex;
      gap: 15px;
      align-items: stretch;
    }
    /* Spelplanen (vänster) */
    #game-container {
      font-family: 'Lucida Console', monospace;
      flex: 0 0 40%;
      height: 280px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #snakeCanvas {
      width: 280px;
      height: 280px;
      border-radius: 8px;
      background-color: var(--primary);
      image-rendering: pixelated;
    }
    /* Förklaringsrutan (höger) */
    #explanation-container {
      flex: 1 1 auto;
      height: 280px;
      padding: 10px;
      background-color: var(--primary);
      color: var(--white);
      border-radius: 8px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 14px;
    }
    
    /* "Step"-rutornas utseende */
    .step-container {
      display: flex;
      gap: 1em;
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 8px;
      animation: fadeIn 0.5s ease-in;
    }
    .step-container.computer {
      background-color: var(--status_graygreen);
      border-left: 5px solid var(--status_olivegreen);
      color: var(--white);
    }
    .step-container.player {
      background-color: var(--status_ochreyellow);
      border-left: 5px solid var(--status_goldenbrown);
      color: var(--white);
    }
    .step-container.prune {
      background-color: var(--status_sienna);
      border-left: 5px solid var(--status_burntumber);
      color: var(--white);
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Knappar */
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    .controls button {
      padding: 10px 20px;
      background-color: var(--dark);
      color: var(--white);
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    .controls button:hover {
      background-color: var(--effect);
    }
    
    /* Statusruta */

    #status {
            background-color: var(--extra_primary);
            font-size: 40px;
            font-weight: bold;
            color: var(--white);
            border-radius: 5px;
            padding: 10px;
            margin: 0;
        }


    #status_outside {
      font-family: 'Poppins', sans-serif;
      background-color: #D98E04;
      border: 1px solid #A44434;
      border-radius: 5px;
      text-align: center;
      margin-top: 20px;
      padding: 15px;
      width: 100%;
    }
    #status_outside span {
      font-size: 40px;
      font-weight: bold;
      color: var(--white);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Snake med Q-learning</h1>
    <p class="inforuta">
      Spelagenten tränas genom förstärkningsinlärning med algoritmen Q‑learning. Ändra variablerna för algoritmen och träna agenten för att nå en så hög highscore som möjligt men med minsta möjliga mängd träningstillfällen. Algoritmen är mycket känslig för valet av hyperparametrar.
    </p>
    
    <!-- Inställningar -->
    <div class="settings">
      <div class="settings-row">
        <div class="settings-item">
          <label for="epsilonDecayInput">Epsilon decay:</label>
          <input id="epsilonDecayInput" type="number" step="0.001" value="0.995">
        </div>
        <div class="settings-item">
          <label for="epsilonMinInput">Epsilon min:</label>
          <input id="epsilonMinInput" type="number" step="0.01" value="0.01">
        </div>
      </div>
      <div class="settings-row">
        <div class="settings-item">
          <label for="learningRateInput">Learning rate:</label>
          <input id="learningRateInput" type="number" step="0.01" value="0.1">
        </div>
        <div class="settings-item">
          <label for="discountFactorInput">Discount factor:</label>
          <input id="discountFactorInput" type="number" step="0.01" value="0.9">
        </div>
      </div>
      <div class="settings-row">
        <div class="settings-item">
          <label for="episodesPerTrainInput">Episoder/träning:</label>
          <input id="episodesPerTrainInput" type="number" step="1" value="100">
        </div>
        <div class="settings-item">
          <label for="trainedEpisodesDisplay">Tränade episoder:</label>
          <input id="trainedEpisodesDisplay" type="number" value="0" readonly>
        </div>
      </div>
    </div>
    
    <!-- Spelplan och förklaringsruta sida vid sida -->
    <div class="outer-game-container">
      <div class="flex-row">
        <!-- Spelplan (Snake) -->
        <div id="game-container">
          <canvas id="snakeCanvas" width="280" height="280"></canvas>
        </div>
        <!-- Förklaringsruta -->
        <div id="explanation-container">
          <div class="step-container computer">
            <div><strong>Epsilon:</strong> Sannolikheten att välja en slumpmässig handling (utforskning).</div>
          </div>
          <div class="step-container player">
            <div><strong>Epsilon decay:</strong> Faktorn med vilken Epsilon minskar vid varje träningsomgång.</div>
          </div>
          <div class="step-container prune">
            <div><strong>Epsilon min:</strong> Det lägsta värdet Epsilon får nå.</div>
          </div>
          <div class="step-container computer">
            <div><strong>Learning rate:</strong> Hur snabbt agenten anpassar sig utifrån nya erfarenheter.</div>
          </div>
          <div class="step-container player">
            <div><strong>Discount factor:</strong> Hur mycket framtida belöningar prioriteras.</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Knappar -->
    <div class="controls">
      <button id="trainBtn">Träna agent</button>
      <button id="testBtn">Testa agent</button>
      <button id="resetBtn">Återställ</button>
    </div>
    
    <hr id="separator" />
    
    <!-- Statusruta -->
    <div id="status_outside">
      <div id="status">
        <span>Epsilon: 1.000</span>
      </div>
    </div>
  </div>
  
  <script>
    const canvas = document.getElementById('snakeCanvas');
    const ctx = canvas.getContext('2d');
    const gridCount = 20;
    const cellSize = canvas.width / gridCount;
    
    let qTable = {};
    const actions = [0, 1, 2];
    let epsilon = 1.0;
    let epsilonMin = parseFloat(document.getElementById('epsilonMinInput').value) || 0.01;
    let epsilonDecay = parseFloat(document.getElementById('epsilonDecayInput').value) || 0.995;
    let learningRate = parseFloat(document.getElementById('learningRateInput').value) || 0.1;
    let discountFactor = parseFloat(document.getElementById('discountFactorInput').value) || 0.9;
    let episodesPerTrain = parseInt(document.getElementById('episodesPerTrainInput').value) || 100;
    let totalEpisodesTrained = 0;
    
    let snake = [];
    let food = {};
    let direction = { x: 0, y: 0 };
    let score = 0;
    let gameInterval = null;
    
    function resetGame() {
      snake = [{ x: Math.floor(gridCount / 2), y: Math.floor(gridCount / 2) }];
      direction = { x: 0, y: -1 };
      score = 0;
      placeFood();
    }
    
    function placeFood() {
      food = {
        x: Math.floor(Math.random() * gridCount),
        y: Math.floor(Math.random() * gridCount)
      };
      while (snake.some(segment => segment.x === food.x && segment.y === food.y)) {
        food = {
          x: Math.floor(Math.random() * gridCount),
          y: Math.floor(Math.random() * gridCount)
        };
      }
    }
    
    function isCollision(pos) {
      if (pos.x < 0 || pos.x >= gridCount || pos.y < 0 || pos.y >= gridCount) return true;
      if (snake.some(segment => segment.x === pos.x && segment.y === pos.y)) return true;
      return false;
    }
    
    function getState() {
      const head = snake[0];
      let leftVec, straightVec, rightVec;
      if (direction.x === 0 && direction.y === -1) {
        leftVec = { x: -1, y: 0 };
        straightVec = { x: 0, y: -1 };
        rightVec = { x: 1, y: 0 };
      } else if (direction.x === 0 && direction.y === 1) {
        leftVec = { x: 1, y: 0 };
        straightVec = { x: 0, y: 1 };
        rightVec = { x: -1, y: 0 };
      } else if (direction.x === -1 && direction.y === 0) {
        leftVec = { x: 0, y: 1 };
        straightVec = { x: -1, y: 0 };
        rightVec = { x: 0, y: -1 };
      } else if (direction.x === 1 && direction.y === 0) {
        leftVec = { x: 0, y: -1 };
        straightVec = { x: 1, y: 0 };
        rightVec = { x: 0, y: 1 };
      }
      const dangerLeft = isCollision({ x: snake[0].x + leftVec.x, y: snake[0].y + leftVec.y }) ? 1 : 0;
      const dangerStraight = isCollision({ x: snake[0].x + straightVec.x, y: snake[0].y + straightVec.y }) ? 1 : 0;
      const dangerRight = isCollision({ x: snake[0].x + rightVec.x, y: snake[0].y + rightVec.y }) ? 1 : 0;
      const foodLeft = food.x < snake[0].x ? 1 : 0;
      const foodRight = food.x > snake[0].x ? 1 : 0;
      const foodUp = food.y < snake[0].y ? 1 : 0;
      const foodDown = food.y > snake[0].y ? 1 : 0;
      return [dangerLeft, dangerStraight, dangerRight, foodLeft, foodRight, foodUp, foodDown].join('');
    }
    
    function getQ(state) {
      if (!(state in qTable)) {
        qTable[state] = [0, 0, 0];
      }
      return qTable[state];
    }
    
    function chooseAction(state) {
      if (Math.random() < epsilon) {
        return actions[Math.floor(Math.random() * actions.length)];
      } else {
        const qValues = getQ(state);
        return qValues.indexOf(Math.max(...qValues));
      }
    }
    
    function updateQ(prevState, action, reward, newState) {
      const qPrev = getQ(prevState)[action];
      const maxFutureQ = Math.max(...getQ(newState));
      const newQ = (1 - learningRate) * qPrev + learningRate * (reward + discountFactor * maxFutureQ);
      qTable[prevState][action] = newQ;
    }
    
    function getNewDirection(currentDir, action) {
      let newDir;
      if (currentDir.x === 0 && currentDir.y === -1) {
        if (action === 0) newDir = { x: -1, y: 0 };
        else if (action === 1) newDir = { x: 0, y: -1 };
        else if (action === 2) newDir = { x: 1, y: 0 };
      } else if (currentDir.x === 0 && currentDir.y === 1) {
        if (action === 0) newDir = { x: 1, y: 0 };
        else if (action === 1) newDir = { x: 0, y: 1 };
        else if (action === 2) newDir = { x: -1, y: 0 };
      } else if (currentDir.x === -1 && currentDir.y === 0) {
        if (action === 0) newDir = { x: 0, y: 1 };
        else if (action === 1) newDir = { x: -1, y: 0 };
        else if (action === 2) newDir = { x: 0, y: -1 };
      } else if (currentDir.x === 1 && currentDir.y === 0) {
        if (action === 0) newDir = { x: 0, y: -1 };
        else if (action === 1) newDir = { x: 1, y: 0 };
        else if (action === 2) newDir = { x: 0, y: 1 };
      }
      return newDir;
    }
    
    function step(action) {
      const prevState = getState();
      direction = getNewDirection(direction, action);
      const newHead = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
      if (isCollision(newHead)) {
        return { reward: -10, gameOver: true, newState: getState() };
      }
      snake.unshift(newHead);
      let reward = -0.1;
      if (newHead.x === food.x && newHead.y === food.y) {
        reward = 10;
        score++;
        placeFood();
      } else {
        snake.pop();
      }
      return { reward, gameOver: false, newState: getState() };
    }
    
    function runEpisode() {
      resetGame();
      let stepsCount = 0;
      const maxSteps = 200;
      let gameOver = false;
      while (!gameOver && stepsCount < maxSteps) {
        const state = getState();
        const action = chooseAction(state);
        const { reward, gameOver: over, newState } = step(action);
        updateQ(state, action, reward, newState);
        gameOver = over;
        stepsCount++;
      }
      return stepsCount;
    }
    
    async function trainAgent(episodes) {
      for (let i = 0; i < episodes; i++) {
        runEpisode();
        epsilon = Math.max(epsilonMin, epsilon * epsilonDecay);
        totalEpisodesTrained++;
        document.getElementById('trainedEpisodesDisplay').value = totalEpisodesTrained;
        document.querySelector('#status_outside span').textContent = `Epsilon: ${epsilon.toFixed(3)}`;
        await new Promise(r => setTimeout(r, 1));
      }
    }
    
    function drawGame() {
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary');
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--extra_primary');
      ctx.fillRect(food.x * cellSize, food.y * cellSize, cellSize, cellSize);
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cell_mediumgreen');
      snake.forEach((segment, index) => {
        ctx.fillRect(segment.x * cellSize, segment.y * cellSize, cellSize, cellSize);
        if (index === 0) {
          ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--extra_red');
          ctx.lineWidth = 2;
          ctx.strokeRect(segment.x * cellSize, segment.y * cellSize, cellSize, cellSize);
        }
      });
    }
    
    function testGame() {
      resetGame();
      const savedEpsilon = epsilon;
      epsilon = 0;
      if (gameInterval) clearInterval(gameInterval);
      gameInterval = setInterval(() => {
        const state = getState();
        const action = chooseAction(state);
        const { reward, gameOver } = step(action);
        drawGame();
        if (gameOver) {
          clearInterval(gameInterval);
          document.querySelector('#status_outside span').textContent = `Epsilon: ${savedEpsilon.toFixed(3)}`;
          epsilon = savedEpsilon;
        }
      }, 80);
    }
    
    document.getElementById('trainBtn').addEventListener('click', async () => {
      epsilonDecay = parseFloat(document.getElementById('epsilonDecayInput').value) || 0.995;
      learningRate = parseFloat(document.getElementById('learningRateInput').value) || 0.1;
      discountFactor = parseFloat(document.getElementById('discountFactorInput').value) || 0.9;
      epsilonMin = parseFloat(document.getElementById('epsilonMinInput').value) || 0.01;
      episodesPerTrain = parseInt(document.getElementById('episodesPerTrainInput').value) || 100;
      await trainAgent(episodesPerTrain);
    });
    
    document.getElementById('testBtn').addEventListener('click', () => {
      testGame();
    });
    
    document.getElementById('resetBtn').addEventListener('click', () => {
      if (gameInterval) clearInterval(gameInterval);
      totalEpisodesTrained = 0;
      epsilon = 1.0;
      qTable = {};
      resetGame();
      drawGame();
      document.getElementById('trainedEpisodesDisplay').value = totalEpisodesTrained;
      document.querySelector('#status_outside span').textContent = 'Epsilon: 1.000';
    });
    
    resetGame();
    drawGame();
  </script>
</body>
</html>
