<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Snake med Q-learning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400&family=Source+Serif+Pro&display=swap" />
  <style>
    :root {
      --bg: #f4f4f4;
      --white: #ffffff;
      --primary: #40534C;
      --cell_mediumgreen: #3CB371;
      --dark: #1A3636;
      --text: #644117;
      --subtle: #D6BD98;
      --effect: #677D6A;
      --placeholder: #B9AFA1;
      --textarea: #FCF8F4;
      --extra_effect: #D98E04;
      --extra_primary: #E0A030;
      --extra_red: #A44434;
      --status_graygreen: #8E9775;
      --status_olivegreen: #5B7052;
      --status_ochreyellow: #D4A76A;
      --status_goldenbrown: #C2955C;
      --status_sienna: #A0522D;
      --status_burntumber: #8A3324;
    }
    
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Source Serif Pro', serif;
      margin: 0;
      padding: 0;
      background-color: var(--bg);
    }
    
    .container {
      width: 740px;
      min-width: 740px;
      background-color: var(--white);
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      padding: 20px;
      margin: 20px auto;
    }
    
    /* Rubrik med titeln och epsilon-v√§rdet */
    h1 {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      font-size: 24px;
      color: var(--white);
      background-color: var(--primary);
      border-radius: 8px 8px 0 0;
      padding: 10px 20px;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .inforuta {
      margin-top: 0;
      font-size: 15px;
      color: var(--text);
      background-color: var(--subtle);
      border-radius: 0 0 8px 8px;
      padding: 10px 20px;
      margin-bottom: 15px;
    }
    
    /* Inst√§llningar ‚Äì placerade mellan spelplanen och knapparna */
    .settings {
      margin-bottom: 15px;
    }
    .settings-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .settings-item {
      flex: 0 0 calc((100% - 20px) / 3);
      display: flex;
      flex-direction: column;
    }
    
    label {
      font-family: monospace;
      color: var(--primary);
      font-size: 14px;
      margin-bottom: 5px;
    }
    input[type="number"] {
      background-color: var(--textarea);
      border: 1px solid var(--effect);
      color: var(--dark);
      font-size: 13px;
      padding: 10px;
      border-radius: 5px;
    }
    input[readonly] {
      background-color: #e8e0c8;
    }
    
    /* Separator */
    #separator {
      border-top: 1px dashed var(--dark);
      margin: 20px 0;
    }
    
    /* Layout: spelplan och f√∂rklaringsruta sida vid sida */
    .outer-game-container {
      background-color: var(--effect);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid var(--primary);
      margin-bottom: 15px;
    }
    .flex-row {
      display: flex;
      gap: 15px;
      align-items: stretch;
    }
    #game-container {
      font-family: 'Lucida Console', monospace;
      flex: 0 0 40%;
      height: 280px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #snakeCanvas {
      width: 280px;
      height: 280px;
      border-radius: 8px;
      background-color: var(--primary);
      image-rendering: pixelated;
    }
    #explanation-container {
      flex: 1 1 auto;
      height: 280px;
      padding: 10px;
      background-color: var(--primary);
      color: var(--white);
      border-radius: 8px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 14px;
      scrollbar-color: var(--effect) var(--primary);
    }
    
    .step-container {
      display: flex;
      gap: 0.5em;
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 8px;
      animation: fadeIn 0.5s ease-in;
    }
    .step-container.computer {
      background-color: var(--status_graygreen);
      border-left: 5px solid var(--status_olivegreen);
      color: var(--white);
    }
    .step-container.player {
      background-color: var(--status_ochreyellow);
      border-left: 5px solid var(--status_goldenbrown);
      color: var(--white);
    }
    .step-container.prune {
      background-color: var(--status_sienna);
      border-left: 5px solid var(--status_burntumber);
      color: var(--white);
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .explanation-content {
      flex: 1;
    }
    .explanation-content .heading {
      margin-bottom: 5px;
    }
    .explanation-content .description {
      margin-bottom: 5px;
    }
    .explanation-content ul {
      margin: 0;
      padding-left: 20px;
    }
    .explanation-emoji {
      font-size: 32px;
      display: flex;
      align-items: center;
    }
    
    /* Knappar: ligger p√• samma rad */
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    .controls button {
      flex: 1;
      padding: 10px 20px;
      background-color: var(--dark);
      color: var(--white);
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    .controls button:hover {
      background-color: var(--effect);
    }
    
    /* Statusruta ‚Äì visar highscore */

    #status {
            background-color: var(--extra_primary);
            font-size: 40px;
            font-weight: bold;
            color: var(--white);
            border-radius: 5px;
            padding: 10px;
            margin: 0;
        }

        /* Klass f√∂r emoji-skugga */
        .emoji-shadow {
            text-shadow: 0px 0px 10px var(--status_sienna);
        }

    #status_outside {
      font-family: 'Poppins', sans-serif;
      background-color: #D98E04;
      border: 1px solid #A44434;
      border-radius: 5px;
      text-align: center;
      margin-top: 20px;
      padding: 15px;
      width: 100%;
    }

  </style>
</head>
<body>
  <div class="container">
    <h1>
      Snake med Q-learning
      <span id="epsilonDisplay" style="font-size:18px;">Œµ: 1.000</span>
    </h1>
    <p class="inforuta">
      Spelagenten tr√§nas genom f√∂rst√§rkningsinl√§rning med algoritmen Q‚Äëlearning. √Ñndra variablerna f√∂r algoritmen och tr√§na agenten f√∂r att n√• en s√• h√∂g highscore som m√∂jligt men med minsta m√∂jliga m√§ngd tr√§ningstillf√§llen. Algoritmen √§r mycket k√§nslig f√∂r valet av hyperparametrar.
    </p>
    
    <!-- Spelplan och f√∂rklaringsruta -->
    <div class="outer-game-container">
      <div class="flex-row">
        <div id="game-container">
          <canvas id="snakeCanvas" width="280" height="280"></canvas>
        </div>
        <div id="explanation-container">
          <div class="step-container computer">
            <div class="explanation-content">
              <div class="heading"><strong>Epsilon:</strong></div>
              <div class="description">Sannolikheten att v√§lja en slumpm√§ssig handling (utforskning).</div>
              <ul>
                <li><strong>H√∂gt v√§rde:</strong> Mer slumpm√§ssighet.</li>
                <li><strong>L√•gt v√§rde:</strong> Mer exploatering.</li>
              </ul>
            </div>
            <div class="explanation-emoji">üé≤</div>
          </div>
          <div class="step-container player">
            <div class="explanation-content">
              <div class="heading"><strong>Epsilon decay:</strong></div>
              <div class="description">Faktorn med vilken Epsilon minskar vid varje tr√§ningsomg√•ng.</div>
              <ul>
                <li><strong>H√∂gt v√§rde:</strong> Bibeh√•ller utforskningen l√§ngre.</li>
                <li><strong>L√•gt v√§rde:</strong> Prioriterar exploatering tidigare.</li>
              </ul>
            </div>
            <div class="explanation-emoji">‚è≥</div>
          </div>
          <div class="step-container prune">
            <div class="explanation-content">
              <div class="heading"><strong>Epsilon min:</strong></div>
              <div class="description">Det l√§gsta v√§rdet Epsilon f√•r n√•.</div>
              <ul>
                <li><strong>H√∂gt v√§rde:</strong> Beh√•ller viss utforskning.</li>
                <li><strong>L√•gt v√§rde:</strong> N√§stan ingen utforskning.</li>
              </ul>
            </div>
            <div class="explanation-emoji">üîª</div>
          </div>
          <div class="step-container computer">
            <div class="explanation-content">
              <div class="heading"><strong>Learning rate:</strong></div>
              <div class="description">Hur snabbt agenten anpassar sig efter nya erfarenheter.</div>
              <ul>
                <li><strong>H√∂gt v√§rde:</strong> Snabb inl√§rning, men risk f√∂r instabilitet.</li>
                <li><strong>L√•gt v√§rde:</strong> L√•ngsammare, men stabil inl√§rning.</li>
              </ul>
            </div>
            <div class="explanation-emoji">‚ö°</div>
          </div>
          <div class="step-container player">
            <div class="explanation-content">
              <div class="heading"><strong>Discount factor:</strong></div>
              <div class="description">Hur mycket framtida bel√∂ningar prioriteras.</div>
              <ul>
                <li><strong>H√∂gt v√§rde:</strong> Framtida bel√∂ningar ges h√∂gt v√§rde.</li>
                <li><strong>L√•gt v√§rde:</strong> Fokuserar mer p√• omedelbara bel√∂ningar.</li>
              </ul>
            </div>
            <div class="explanation-emoji">üîÆ</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Inst√§llningar -->
    <div class="settings">
      <div class="settings-row">
        <div class="settings-item">
          <label for="epsilonDecayInput">Epsilon decay:</label>
          <input id="epsilonDecayInput" type="number" step="0.001" value="0.995">
        </div>
        <div class="settings-item">
          <label for="epsilonMinInput">Epsilon min:</label>
          <input id="epsilonMinInput" type="number" step="0.01" value="0.01">
        </div>
        <div class="settings-item">
          <label for="episodesPerTrainInput">Episoder/tr√§ning:</label>
          <input id="episodesPerTrainInput" type="number" step="1" value="1000">
        </div>
      </div>
      <div class="settings-row">
        <div class="settings-item">
          <label for="learningRateInput">Learning rate:</label>
          <input id="learningRateInput" type="number" step="0.01" value="0.1">
        </div>
        <div class="settings-item">
          <label for="discountFactorInput">Discount factor:</label>
          <input id="discountFactorInput" type="number" step="0.01" value="0.9">
        </div>
        <div class="settings-item">
          <label for="trainedEpisodesDisplay">Tr√§nade episoder:</label>
          <input id="trainedEpisodesDisplay" type="number" value="0" readonly>
        </div>
      </div>
    </div>
    
    <!-- Knappar -->
    <div class="controls">
      <button id="trainBtn">Tr√§na agent</button>
      <button id="testBtn">Testa agent</button>
    </div>
    
    <hr id="separator" />
    
    <!-- Statusruta: visar highscore -->
    <div id="status_outside">
        <div id="status">
          <span class="emoji-shadow">üèÜ 0</span>
        </div>
    </div>
  </div>
  
  <script>
    const canvas = document.getElementById('snakeCanvas');
    const ctx = canvas.getContext('2d');
    const gridCount = 20;
    const cellSize = canvas.width / gridCount;
    
    let qTable = {};
    const actions = [0, 1, 2];
    let epsilon = 1.0;
    let epsilonMin = parseFloat(document.getElementById('epsilonMinInput').value) || 0.01;
    let epsilonDecay = parseFloat(document.getElementById('epsilonDecayInput').value) || 0.995;
    let learningRate = parseFloat(document.getElementById('learningRateInput').value) || 0.1;
    let discountFactor = parseFloat(document.getElementById('discountFactorInput').value) || 0.9;
    let episodesPerTrain = parseInt(document.getElementById('episodesPerTrainInput').value) || 100;
    // √Öterinf√∂rd variabel f√∂r UI-uppdatering (var 100:e episod)
    const updateFrequency = 1000;
    let totalEpisodesTrained = 0;
    
    let highscore = 0;
    
    let snake = [];
    let food = {};
    let direction = { x: 0, y: 0 };
    let score = 0;
    let gameInterval = null;
    
    function resetGame() {
      snake = [{ x: Math.floor(gridCount / 2), y: Math.floor(gridCount / 2) }];
      direction = { x: 0, y: -1 };
      score = 0;
      placeFood();
    }
    
    function placeFood() {
      food = {
        x: Math.floor(Math.random() * gridCount),
        y: Math.floor(Math.random() * gridCount)
      };
      while (snake.some(segment => segment.x === food.x && segment.y === food.y)) {
        food = {
          x: Math.floor(Math.random() * gridCount),
          y: Math.floor(Math.random() * gridCount)
        };
      }
    }
    
    function isCollision(pos) {
      if (pos.x < 0 || pos.x >= gridCount || pos.y < 0 || pos.y >= gridCount) return true;
      if (snake.some(segment => segment.x === pos.x && segment.y === pos.y)) return true;
      return false;
    }
    
    function getState() {
      const head = snake[0];
      let leftVec, straightVec, rightVec;
      if (direction.x === 0 && direction.y === -1) {
        leftVec = { x: -1, y: 0 };
        straightVec = { x: 0, y: -1 };
        rightVec = { x: 1, y: 0 };
      } else if (direction.x === 0 && direction.y === 1) {
        leftVec = { x: 1, y: 0 };
        straightVec = { x: 0, y: 1 };
        rightVec = { x: -1, y: 0 };
      } else if (direction.x === -1 && direction.y === 0) {
        leftVec = { x: 0, y: 1 };
        straightVec = { x: -1, y: 0 };
        rightVec = { x: 0, y: -1 };
      } else if (direction.x === 1 && direction.y === 0) {
        leftVec = { x: 0, y: -1 };
        straightVec = { x: 1, y: 0 };
        rightVec = { x: 0, y: 1 };
      }
      const dangerLeft = isCollision({ x: snake[0].x + leftVec.x, y: snake[0].y + leftVec.y }) ? 1 : 0;
      const dangerStraight = isCollision({ x: snake[0].x + straightVec.x, y: snake[0].y + straightVec.y }) ? 1 : 0;
      const dangerRight = isCollision({ x: snake[0].x + rightVec.x, y: snake[0].y + rightVec.y }) ? 1 : 0;
      const foodLeft = food.x < snake[0].x ? 1 : 0;
      const foodRight = food.x > snake[0].x ? 1 : 0;
      const foodUp = food.y < snake[0].y ? 1 : 0;
      const foodDown = food.y > snake[0].y ? 1 : 0;
      return [dangerLeft, dangerStraight, dangerRight, foodLeft, foodRight, foodUp, foodDown].join('');
    }
    
    function getQ(state) {
      if (!(state in qTable)) {
        qTable[state] = [0, 0, 0];
      }
      return qTable[state];
    }
    
    function chooseAction(state) {
      if (Math.random() < epsilon) {
        return actions[Math.floor(Math.random() * actions.length)];
      } else {
        const qValues = getQ(state);
        return qValues.indexOf(Math.max(...qValues));
      }
    }
    
    function updateQ(prevState, action, reward, newState) {
      const qPrev = getQ(prevState)[action];
      const maxFutureQ = Math.max(...getQ(newState));
      const newQ = (1 - learningRate) * qPrev + learningRate * (reward + discountFactor * maxFutureQ);
      qTable[prevState][action] = newQ;
    }
    
    function getNewDirection(currentDir, action) {
      let newDir;
      if (currentDir.x === 0 && currentDir.y === -1) {
        if (action === 0) newDir = { x: -1, y: 0 };
        else if (action === 1) newDir = { x: 0, y: -1 };
        else if (action === 2) newDir = { x: 1, y: 0 };
      } else if (currentDir.x === 0 && currentDir.y === 1) {
        if (action === 0) newDir = { x: 1, y: 0 };
        else if (action === 1) newDir = { x: 0, y: 1 };
        else if (action === 2) newDir = { x: -1, y: 0 };
      } else if (currentDir.x === -1 && currentDir.y === 0) {
        if (action === 0) newDir = { x: 0, y: 1 };
        else if (action === 1) newDir = { x: -1, y: 0 };
        else if (action === 2) newDir = { x: 0, y: -1 };
      } else if (currentDir.x === 1 && currentDir.y === 0) {
        if (action === 0) newDir = { x: 0, y: -1 };
        else if (action === 1) newDir = { x: 1, y: 0 };
        else if (action === 2) newDir = { x: 0, y: 1 };
      }
      return newDir;
    }
    
    function step(action) {
      const prevState = getState();
      direction = getNewDirection(direction, action);
      const newHead = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
      if (isCollision(newHead)) {
        return { reward: -10, gameOver: true, newState: getState() };
      }
      snake.unshift(newHead);
      let reward = -0.1;
      if (newHead.x === food.x && newHead.y === food.y) {
        reward = 10;
        score++;
        placeFood();
      } else {
        snake.pop();
      }
      return { reward, gameOver: false, newState: getState() };
    }
    
    // Funktion f√∂r att k√∂ra en episod utan extra bestraffning
    function runEpisode() {
      resetGame();
      let stepsCount = 0;
      const maxSteps = 200;
      let gameOver = false;
      while (!gameOver && stepsCount < maxSteps) {
        const state = getState();
        const action = chooseAction(state);
        const { reward, gameOver: over, newState } = step(action);
        updateQ(state, action, reward, newState);
        gameOver = over;
        stepsCount++;
      }
      return stepsCount;
    }
    
    async function trainAgent(episodes) {
      for (let i = 0; i < episodes; i++) {
        runEpisode();
        epsilon = Math.max(epsilonMin, epsilon * epsilonDecay);
        totalEpisodesTrained++;
        if ((i + 1) % updateFrequency === 0 || i === episodes - 1) {
          document.getElementById('trainedEpisodesDisplay').value = totalEpisodesTrained;
          document.getElementById('epsilonDisplay').textContent = `Œµ: ${epsilon.toFixed(3)}`;
          await new Promise(r => setTimeout(r, 1));
        }
      }
    }
    
    function drawGame() {
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary');
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--extra_primary');
      ctx.fillRect(food.x * cellSize, food.y * cellSize, cellSize, cellSize);
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cell_mediumgreen');
      snake.forEach((segment, index) => {
        ctx.fillRect(segment.x * cellSize, segment.y * cellSize, cellSize, cellSize);
        if (index === 0) {
          ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--extra_red');
          ctx.lineWidth = 2;
          ctx.strokeRect(segment.x * cellSize, segment.y * cellSize, cellSize, cellSize);
        }
      });
    }
    
    function testGame() {
      resetGame();
      const savedEpsilon = epsilon;
      epsilon = 0;
      if (gameInterval) clearInterval(gameInterval);
      gameInterval = setInterval(() => {
        const state = getState();
        const action = chooseAction(state);
        const { gameOver } = step(action);
        drawGame();
        if (gameOver) {
          clearInterval(gameInterval);
          if (score > highscore) { highscore = score; }
          document.querySelector('#status_outside span').textContent = `üèÜ ${highscore}`;
          epsilon = savedEpsilon;
        }
      }, 80);
    }
    
    document.getElementById('trainBtn').addEventListener('click', async () => {
      epsilonDecay = parseFloat(document.getElementById('epsilonDecayInput').value) || 0.995;
      learningRate = parseFloat(document.getElementById('learningRateInput').value) || 0.1;
      discountFactor = parseFloat(document.getElementById('discountFactorInput').value) || 0.9;
      epsilonMin = parseFloat(document.getElementById('epsilonMinInput').value) || 0.01;
      episodesPerTrain = parseInt(document.getElementById('episodesPerTrainInput').value) || 100;
      await trainAgent(episodesPerTrain);
    });
    
    document.getElementById('testBtn').addEventListener('click', () => {
      testGame();
    });
    
    resetGame();
    drawGame();
  </script>
</body>
</html>
