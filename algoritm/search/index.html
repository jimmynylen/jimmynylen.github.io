<!DOCTYPE html>
<html lang="sv">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisering av s√∂kalgoritmer</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Poppins:wght@400&family=Source+Serif+Pro&display=swap">
    <style>
        :root {
            --bg: #f4f4f4;
            --white: #ffffff;
            --primary: #40534C;
            --dark: #1A3636;
            --text: #644117;
            --subtle: #D6BD98;
            --effect: #677D6A;
            --placeholder: #B9AFA1;
            --textarea: #FCF8F4;
            --extra_effect: #D98E04;
            --extra_primary: #E0A030;
            --extra_primary_dark: #705018;
            --extra_red: #A44434;
            --extra_red_dark: #52221A;
            /* F√§rgkombinationer f√∂r h√§ndelser (bakgrund / v√§nsterram) */
            --status_graygreen: #8E9775;
            --status_olivegreen: #5B7052;
            --status_ochreyellow: #D4A76A;
            --status_goldenbrown: #C2955C;
            --status_sienna: #A0522D;
            --status_burntumber: #8A3324;
            --status_sandbrown: #C4A484;
            --status_terracotta: #A66A4C;
            --status_bronze: #CD7F32;
            --status_cinnamon: #D2691E;
            /* Standardf√§rger f√∂r noder */
            --node_normal: var(--status_graygreen);
            --node_visited: var(--cell_mediumgreen, #3CB371);
            --node_current: #ffbf00;
        }

        body {
            font-family: 'Source Serif Pro', serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg);
        }

        .container {
            max-width: 700px;
            background-color: var(--white);
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin: 20px auto;
        }

        h1 {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            font-size: 24px;
            color: var(--white);
            background-color: var(--primary);
            border-radius: 8px 8px 0 0;
            padding: 10px 20px;
            box-sizing: border-box;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .inforuta {
            margin-top: 0;
            font-size: 15px;
            color: var(--text);
            background-color: var(--subtle);
            border-radius: 0 0 8px 8px;
            padding: 10px 20px;
            margin-bottom: 15px;
        }

        a {
            color: var(--primary);
            text-decoration: none;
        }

        a:hover {
            color: var(--extra_red);
        }

        .controls-top {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        /* Flex-baserade breddinst√§llningar med gap: 40%, 40%, 20% */
        #algorithmSelect {
            flex: 0 0 calc(40% - 6.67px);
            padding: 8px;
            background-color: var(--textarea);
            border: 1px solid var(--effect);
            color: var(--dark);
            border-radius: 5px;
        }

        #nodesSelect {
            flex: 0 0 calc(40% - 6.67px);
            padding: 8px;
            background-color: var(--textarea);
            border: 1px solid var(--effect);
            color: var(--dark);
            border-radius: 5px;
        }

        #generateGraphBtn {
            flex: 0 0 calc(20% - 6.67px);
            padding: 10px;
            background-color: var(--dark);
            color: var(--white);
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #generateGraphBtn:hover {
            background-color: var(--effect);
        }

        .visualization-wrapper {
            background-color: var(--effect);
            padding: 15px;
            border: 1px solid var(--primary);
            border-radius: 8px;
            margin-top: 15px;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Grafbeh√•llare */
        #graph-container {
            position: relative;
            width: 100%;
            height: 350px;
            background-color: var(--primary);
            border-radius: 8px;
            overflow: hidden;
        }

        /* Noder ritas ut som cirklar */
        .node {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: var(--node_normal);
            text-align: center;
            line-height: 30px;
            font-family: monospace;
            color: var(--white);
            transition: background-color 0.3s, border 0.3s;
            z-index: 2;
        }

        .node.visited {
            background-color: var(--node_visited);
        }

        .node.current {
            border: 3px solid var(--node_current);
        }

        /* SVG f√∂r kanter */
        #graph-svg {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Fast h√∂jd f√∂r visualiseringsrutan */
        #visualization-container {
            box-sizing: border-box;
            scrollbar-color: var(--effect) var(--primary);
            height: 215px;
            overflow-y: auto;
        }

        #visualization {
            font-size: 12px;
            background-color: var(--primary);
            border-radius: 8px;
            box-sizing: border-box;
            padding: 5px;
            height: 215px;
            overflow-y: auto;
        }

        /* Stegrutor ‚Äì vit text, v√§nsterram 5px, och extra h√∂gerpadding f√∂r att undvika √∂verlapp med emoji */
        .step-container {
            position: relative;
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
            padding: 10px 50px 10px 10px;
            /* √ñkad h√∂gerpadding */
            border-left: 5px solid;
            border-radius: 8px;
            font-family: monospace;
            color: #fff;
        }

        .step-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            /* Notera att vi inte l√§ngre beh√∂ver extra padding h√§r eftersom f√∂r√§ldern har r√§tt padding */
        }

        .step-emoji {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            font-size: 22px;
        }

        .step-description {
            font-size: 14px;
        }

        .step-array {
            font-size: 12px;
        }

        .controls-bottom {
            width: 100%;
            margin-top: 10px;
        }

        #startSearchBtn {
            width: 100%;
            padding: 10px;
            background-color: var(--dark);
            color: var(--white);
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #startSearchBtn:hover {
            background-color: var(--effect);
        }

        /* Sammanfattningsruta ‚Äì fast f√§rg, vit text, v√§nsterram 5px */
        .summary {
            background-color: var(--extra_primary);
            border-left: 5px solid var(--extra_effect);
            border-radius: 8px;
            padding: 10px;
            color: #fff;
            font-family: monospace;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .summary-text h3 {
            margin: 0;
            font-size: 16px;
        }

        .summary-text p {
            margin: 3px 0 0 0;
            font-size: 12px;
        }

        .summary-emoji {
            font-size: 22px;
        }

        .explanation-box {
            background-color: var(--status_graygreen);
            color: var(--white);
            border-left: 5px solid var(--status_olivegreen);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 15px;
            font-family: monospace;
            cursor: pointer;
        }

        .explanation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .explanation-description {
            font-size: 14px;
        }

        .explanation-emoji {
            font-size: 22px;
        }

        .pseudocode-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }

        .pseudocode-content.expanded {
            max-height: 1000px;
        }

        .pseudocode-content pre {
            margin-bottom: 0;
            padding-bottom: 5px;
        }

        .fade-in {
            opacity: 0;
            transition: opacity 0.5s;
        }

        .fade-in.show {
            opacity: 1;
        }

        @media (max-width: 600px) {
            .controls-top {
                flex-direction: column;
                align-items: flex-start;
            }

            #algorithmSelect,
            #nodesSelect,
            #generateGraphBtn {
                flex: 0 0 100%;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Visualisering av s√∂kalgoritmer</h1>
        <p class="inforuta">
            En visuell demonstration av s√∂kalgoritmer. Denna visualisering komplementeras f√∂rslagsvis med en visualisering i en labyrint, s√•som den fr√•n <a href="https://clementmihailescu.github.io/Pathfinding-Visualizer/">Clement Mihailescu</a>
        </p>
        <div class="controls-top">
            <select id="algorithmSelect">
        <option value="dfs">DFS - Depth-first search</option>
        <option value="bfs">BFS - Breadth-first search</option>
        <option value="iddfs">IDDFS - Iterative Deepening DFS</option>
      </select>
            <select id="nodesSelect">
        <option value="15">15 noder</option>
        <option value="16">16 noder</option>
        <option value="17">17 noder</option>
        <option value="18">18 noder</option>
        <option value="19">19 noder</option>
        <option value="20">20 noder</option>
        <option value="21">21 noder</option>
        <option value="22">22 noder</option>
        <option value="23">23 noder</option>
        <option value="24">24 noder</option>
        <option value="25" selected>25 noder</option>
        <option value="26">26 noder</option>
        <option value="27">27 noder</option>
        <option value="28">28 noder</option>
        <option value="29">29 noder</option>
        <option value="30">30 noder</option>
      </select>
            <button id="generateGraphBtn">Generera ny graf</button>
        </div>
        <div class="visualization-wrapper">
            <div id="graph-container"></div>
            <div id="visualization-container">
                <div id="visualization"></div>
            </div>
        </div>
        <div class="controls-bottom">
            <button id="startSearchBtn">Starta s√∂kning</button>
        </div>
    </div>
    <script>
        /*******************************************************
     * Globala variabler
     *******************************************************/
    let graph = null; // Inneh√•ller noder och kanter
    let graphNodeElements = {}; // Kopplar node (nummer) till dess DOM-element
    let steps = [];
    let currentStep = 0;
    const animationDelay = 500; // ms mellan stegen
    let searchInterval = null;

    const algorithmExplanations = {
      dfs: "DFS (Depth-first search) bes√∂ker s√• djupt som m√∂jligt innan den backtrackar.",
      bfs: "BFS (Breadth-first search) bes√∂ker noder niv√• f√∂r niv√•.",
      iddfs: "IDDFS (Iterative Deepening DFS) utf√∂r DFS med successivt √∂kande djupbegr√§nsning."
    };

    const algorithmPseudocode = {
      dfs: `<pre>
function DFS(node):
  markera node som bes√∂kt
  s√§tt node som aktuell
  for each child of node:
    if child is not visited:
      DFS(child)
  ta bort 'aktuell' fr√•n node
</pre>`,
      bfs: `<pre>
function BFS(start):
  queue = [start]
  markera start som bes√∂kt & aktuell
  while queue is not empty:
    node = dequeue from queue
    for each child of node:
      if child is not visited:
        markera child som bes√∂kt & aktuell
        enqueue(child)
    ta bort 'aktuell' fr√•n node
</pre>`,
      iddfs: `<pre>
function IDDFS(root, maxDepth):
  for depth = 0 to maxDepth:
    DLS(root, depth)

function DLS(node, limit):
  if limit < 0: return
  markera node som bes√∂kt
  s√§tt node som aktuell
  for each child of node:
    if child is not visited:
      DLS(child, limit - 1)
  ta bort 'aktuell' fr√•n node
</pre>`
    };

    /*******************************************************
     * Funktion: V√§lj en unik emoji baserat p√• h√§ndelsebeskrivningen.
     *******************************************************/
    function getEmojiForDescription(description) {
      if (description.includes("Bes√∂ker nod") && !description.includes("DLS:")) {
        return "üîé";
      } else if (description.includes("Avslutar nod") && !description.includes("DLS:")) {
        return "üõë";
      } else if (description.includes("Processar nod")) {
        return "üîÑ";
      } else if (description.includes("L√§gger till nod")) {
        return "‚ûï";
      } else if (description.includes("F√§rdig med nod")) {
        return "‚úÖ";
      } else if (description.includes("IDDFS iteration")) {
        return "‚ôªÔ∏è";
      } else if (description.includes("DLS: Bes√∂ker nod")) {
        return "üîç";
      } else if (description.includes("DLS: Avslutar nod")) {
        return "‚úîÔ∏è"; // Unik emoji f√∂r DLS: Avslutar nod
      } else {
        return "‚ùì";
      }
    }

    /*******************************************************
     * Funktion: V√§lj f√§rgkombination baserat p√• h√§ndelsebeskrivningen.
     * F√∂r IDDFS iteration, v√§lj en unik kombination som inte anv√§nds f√∂r DLS-h√§ndelser.
     *******************************************************/
    function getColorForDescription(description) {
      const style = getComputedStyle(document.documentElement);
      if (description.includes("Bes√∂ker nod") && !description.includes("DLS:")) {
        return { bg: style.getPropertyValue('--status_graygreen').trim(), border: style.getPropertyValue('--status_olivegreen').trim() };
      } else if (description.includes("Avslutar nod") && !description.includes("DLS:")) {
        return { bg: style.getPropertyValue('--status_ochreyellow').trim(), border: style.getPropertyValue('--status_goldenbrown').trim() };
      } else if (description.includes("Processar nod")) {
        return { bg: style.getPropertyValue('--status_sienna').trim(), border: style.getPropertyValue('--status_burntumber').trim() };
      } else if (description.includes("L√§gger till nod")) {
        return { bg: style.getPropertyValue('--status_sandbrown').trim(), border: style.getPropertyValue('--status_terracotta').trim() };
      } else if (description.includes("F√§rdig med nod")) {
        return { bg: style.getPropertyValue('--status_bronze').trim(), border: style.getPropertyValue('--status_cinnamon').trim() };
      } else if (description.includes("IDDFS iteration")) {
        return { bg: style.getPropertyValue('--status_bronze').trim(), border: style.getPropertyValue('--status_cinnamon').trim() };
      } else if (description.includes("DLS: Bes√∂ker nod")) {
        return { bg: style.getPropertyValue('--status_graygreen').trim(), border: style.getPropertyValue('--status_olivegreen').trim() };
      } else if (description.includes("DLS: Avslutar nod")) {
        return { bg: style.getPropertyValue('--status_ochreyellow').trim(), border: style.getPropertyValue('--status_goldenbrown').trim() };
      } else {
        return { bg: style.getPropertyValue('--status_graygreen').trim(), border: style.getPropertyValue('--status_olivegreen').trim() };
      }
    }

    /*******************************************************
     * 1. Bygg ett slumpm√§ssigt tr√§d med max 3 barn per nod.
     *    Exakt totalt antal noder (15‚Äì30) med √∂vre niv√•gr√§ns 5.
     *******************************************************/
    function buildGraph() {
      let totalNodes = parseInt(document.getElementById("nodesSelect").value, 10);
      if (totalNodes < 15) totalNodes = 15;
      if (totalNodes > 30) totalNodes = 30;
      const maxLevels = 5;
      let nodes = [];
      let nextId = 0;
      const root = { id: nextId++, level: 0, visited: false, current: false, children: 0 };
      nodes.push(root);
      let eligible = [root];
      while (nodes.length < totalNodes && eligible.length > 0) {
        let parentIndex = Math.floor(Math.random() * eligible.length);
        let parent = eligible[parentIndex];
        let newNode = { id: nextId++, level: parent.level + 1, visited: false, current: false, parent: parent.id, children: 0 };
        nodes.push(newNode);
        if (newNode.level < maxLevels - 1) {
          eligible.push(newNode);
        }
        parent.children = (parent.children || 0) + 1;
        if (parent.children >= 3) {
          eligible.splice(parentIndex, 1);
        } else if (parent.children === 2) {
          if (Math.random() < 0.7) {
            eligible.splice(parentIndex, 1);
          }
        }
      }
      let edges = [];
      nodes.forEach(n => {
        if (n.level > 0 && n.parent !== undefined) {
          edges.push({ from: n.parent, to: n.id });
        }
      });
      graph = { nodes, edges };

      // F√∂rst ber√§knas layouten (s√§tter x och y)
      computeTreeLayout();
      // Sedan tilldelas noderna nummer baserat p√• deras x-koordinat
      assignNumbers();
    }

    /*******************************************************
     * 1b. Tilldela sekventiella nummer (utom roten).
     *******************************************************/
    function assignNumbers() {
      let levels = {};
      graph.nodes.forEach(n => {
        if (n.level > 0) {
          if (!levels[n.level]) levels[n.level] = [];
          levels[n.level].push(n);
        }
      });
      let currentNumber = 1;
      Object.keys(levels).sort((a, b) => a - b).forEach(levelKey => {
        let levelNodes = levels[levelKey];
        levelNodes.sort((a, b) => a.x - b.x);
        levelNodes.forEach(n => {
          n.number = currentNumber++;
        });
      });
    }

    /*******************************************************
     * 2. Ber√§kna en strukturerad layout med "tidy tree"-algoritm.
     *******************************************************/
    function computeTreeLayout() {
      let childrenMap = {};
      graph.nodes.forEach(n => { childrenMap[n.id] = []; });
      graph.nodes.forEach(n => {
        if (n.parent !== undefined) {
          childrenMap[n.parent].push(n);
        }
      });
      const container = document.getElementById("graph-container");
      const width = container.clientWidth;
      const height = container.clientHeight;
      const leaves = graph.nodes.filter(n => childrenMap[n.id].length === 0);
      const numLeaves = leaves.length;
      const xSpacing = width / (numLeaves + 1);
      let nextX = 0;
      function assignX(node) {
        const children = childrenMap[node.id];
        if (children.length === 0) {
          node.x = (nextX + 1) * xSpacing;
          nextX++;
        } else {
          children.forEach(child => assignX(child));
          let sum = 0;
          children.forEach(child => { sum += child.x; });
          node.x = sum / children.length;
        }
      }
      const root = graph.nodes.find(n => n.level === 0);
      assignX(root);
      const maxLevel = Math.max(...graph.nodes.map(n => n.level));
      graph.nodes.forEach(n => {
        n.y = (n.level + 0.5) * (height / (maxLevel + 1));
      });
    }

    /*******************************************************
     * 3. Rendera grafen ‚Äì visa kanter och noder.
     *******************************************************/
    function renderGraph() {
      buildGraph();
      const container = document.getElementById("graph-container");
      container.innerHTML = "";
      graphNodeElements = {};
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("id", "graph-svg");
      svg.setAttribute("width", container.clientWidth);
      svg.setAttribute("height", container.clientHeight);
      container.appendChild(svg);
      graph.edges.forEach(edge => {
        const fromNode = graph.nodes.find(n => n.id === edge.from);
        const toNode = graph.nodes.find(n => n.id === edge.to);
        const line = document.createElementNS(svgNS, "line");
        line.setAttribute("x1", fromNode.x);
        line.setAttribute("y1", fromNode.y);
        line.setAttribute("x2", toNode.x);
        line.setAttribute("y2", toNode.y);
        line.setAttribute("stroke", varOrFallback("--extra_effect", "#D98E04"));
        line.setAttribute("stroke-width", "2");
        svg.appendChild(line);
      });
      graph.nodes.forEach(node => {
        const nodeEl = document.createElement("div");
        nodeEl.className = "node";
        nodeEl.style.left = (node.x - 15) + "px";
        nodeEl.style.top = (node.y - 15) + "px";
        nodeEl.textContent = node.level === 0 ? "0" : node.number;
        container.appendChild(nodeEl);
        graphNodeElements[node.id] = nodeEl;
      });
    }

    function varOrFallback(variable, fallback) {
      return getComputedStyle(document.documentElement).getPropertyValue(variable) || fallback;
    }

    /*******************************************************
     * 4. Uppdatera grafen utifr√•n snapshot.
     *******************************************************/
    function updateGraph(snapshot) {
      snapshot.forEach(nodeSnap => {
        const el = graphNodeElements[nodeSnap.id];
        el.classList.remove("visited", "current");
        if (nodeSnap.visited) el.classList.add("visited");
        if (nodeSnap.current) el.classList.add("current");
      });
    }

    /*******************************************************
     * 5. Inspelning av s√∂ksteg.
     *******************************************************/
    function recordStep(description, type) {
      const snapshot = graph.nodes.map(n => ({
        id: n.id,
        visited: n.visited,
        current: n.current
      }));
      steps.push({ description, type, snapshot });
    }

    /*******************************************************
     * 6. DFS ‚Äì rekursiv s√∂kning.
     *******************************************************/
    function dfs(nodeId) {
      const node = graph.nodes.find(n => n.id === nodeId);
      node.visited = true;
      node.current = true;
      recordStep("Bes√∂ker nod " + (node.level === 0 ? "root" : node.number), "dfs");
      const children = graph.nodes.filter(n => n.parent === nodeId);
      children.forEach(child => {
        if (!child.visited) dfs(child.id);
      });
      node.current = false;
      recordStep("Avslutar nod " + (node.level === 0 ? "root" : node.number), "dfs");
    }

    /*******************************************************
     * 7. BFS ‚Äì iterativ s√∂kning.
     *******************************************************/
    function bfs() {
      const queue = [];
      const startNode = graph.nodes.find(n => n.id === 0);
      startNode.visited = true;
      startNode.current = true;
      recordStep("Start: Bes√∂ker root", "bfs");
      queue.push(0);
      while (queue.length > 0) {
        const nodeId = queue.shift();
        const node = graph.nodes.find(n => n.id === nodeId);
        node.current = true;
        recordStep("Processar nod " + (node.level === 0 ? "root" : node.number), "bfs");
        const children = graph.nodes.filter(n => n.parent === nodeId);
        children.forEach(child => {
          if (!child.visited) {
            child.visited = true;
            child.current = true;
            recordStep("L√§gger till nod " + child.number, "bfs");
            queue.push(child.id);
          }
        });
        node.current = false;
        recordStep("F√§rdig med nod " + (node.level === 0 ? "root" : node.number), "bfs");
      }
    }

    /*******************************************************
     * 7b. IDDFS ‚Äì Iterative Deepening DFS.
     *******************************************************/
    function iddfs(rootId, maxDepth) {
      for (let limit = 0; limit <= maxDepth; limit++) {
        recordStep("IDDFS iteration med djupbegr√§nsning " + limit, "iddfs");
        dls(rootId, limit);
        graph.nodes.forEach(n => { n.visited = false; n.current = false; });
      }
    }

    function dls(nodeId, limit) {
      if (limit < 0) return;
      let node = graph.nodes.find(n => n.id === nodeId);
      if (!node) return;
      node.visited = true;
      node.current = true;
      recordStep("DLS: Bes√∂ker nod " + (node.level === 0 ? "root" : node.number) + " (limit " + limit + ")", "iddfs");
      if (limit > 0) {
        let children = graph.nodes.filter(n => n.parent === nodeId);
        children.forEach(child => {
          if (!child.visited) dls(child.id, limit - 1);
        });
      }
      node.current = false;
      // Unik emoji f√∂r DLS: Avslutar nod
      recordStep("DLS: Avslutar nod " + (node.level === 0 ? "root" : node.number) + " (limit " + limit + ")", "iddfs");
    }

    /*******************************************************
     * 8. Animation av inspelade steg.
     *******************************************************/
    function animateSteps() {
      currentStep = 0;
      const startBtn = document.getElementById("startSearchBtn");
      startBtn.textContent = "Avbryt nuvarande s√∂kning";
      searchInterval = setInterval(() => {
        if (currentStep >= steps.length) {
          clearInterval(searchInterval);
          searchInterval = null;
          // Skapa sammanfattningsruta med fast f√§rg
          const summaryEl = document.createElement('div');
          summaryEl.className = 'summary fade-in';
          summaryEl.style.backgroundColor = "var(--extra_primary)";
          summaryEl.style.borderLeft = "5px solid var(--extra_effect)";
          summaryEl.style.color = "#fff";
          summaryEl.innerHTML = `
            <div class="summary-text">
              <h3>Sammanfattning</h3>
              <p>Totalt antal steg: ${steps.length}</p>
            </div>
            <div class="summary-emoji">üìä</div>
          `;
          document.getElementById("visualization").appendChild(summaryEl);
          setTimeout(() => summaryEl.classList.add('show'), 10);
          document.getElementById("visualization").scrollTop = document.getElementById("visualization").scrollHeight;
          startBtn.textContent = "Starta s√∂kning";
          return;
        }
        const step = steps[currentStep];
        updateGraph(step.snapshot);
        const colors = getColorForDescription(step.description);
        const emoji = getEmojiForDescription(step.description);
        const stepEl = document.createElement('div');
        stepEl.innerHTML = `
          <div class="step-container ${step.type}" style="background-color: ${colors.bg}; border-left: 5px solid ${colors.border}; color: #fff;">
            <div class="step-header">
              <div class="step-description">${step.description}</div>
              <div class="step-emoji">${emoji}</div>
            </div>
            <div class="step-array">[${step.snapshot.map(n => n.id + (n.visited ? "*" : "")).join(" ")}]</div>
          </div>
        `;
        stepEl.className = 'fade-in';
        document.getElementById("visualization").appendChild(stepEl);
        setTimeout(() => stepEl.classList.add('show'), 10);
        document.getElementById("visualization").scrollTop = document.getElementById("visualization").scrollHeight;
        currentStep++;
      }, animationDelay);
    }

    /*******************************************************
     * 9. F√∂rklarings- och pseudokodsruta.
     *******************************************************/
    function createExplanationAndPseudocode(algo) {
      const visualization = document.getElementById("visualization");
      visualization.innerHTML = "";
      const combinedEl = document.createElement('div');
      combinedEl.className = 'explanation-box fade-in';
      combinedEl.innerHTML = `
        <div class="explanation-header">
          <div class="explanation-description">
            ${algorithmExplanations[algo]}
          </div>
          <div class="explanation-emoji">‚ÑπÔ∏è</div>
        </div>
        <div class="pseudocode-content">
          <h3>Pseudokod</h3>
          ${algorithmPseudocode[algo]}
        </div>
      `;
      visualization.appendChild(combinedEl);
      setTimeout(() => combinedEl.classList.add('show'), 10);
      const header = combinedEl.querySelector('.explanation-header');
      const codeContent = combinedEl.querySelector('.pseudocode-content');
      header.addEventListener('click', () => {
        codeContent.classList.toggle('expanded');
      });
    }

    /*******************************************************
     * 10. Generera en ny graf och rensa s√∂ksteg.
     *******************************************************/
    function generateNewGraph() {
      if (searchInterval !== null) {
        clearInterval(searchInterval);
        searchInterval = null;
        document.getElementById("startSearchBtn").textContent = "Starta s√∂kning";
      }
      steps = [];
      if (graph && graph.nodes) {
        graph.nodes.forEach(n => { n.visited = false; n.current = false; });
      }
      renderGraph();
      const algo = document.getElementById("algorithmSelect").value;
      createExplanationAndPseudocode(algo);
    }

    /*******************************************************
     * 11. Koppla knappar och dropdown.
     *******************************************************/
    document.getElementById("generateGraphBtn").addEventListener('click', () => {
      document.getElementById("visualization").innerHTML = "";
      generateNewGraph();
    });
    document.getElementById("algorithmSelect").addEventListener('change', () => {
      if (searchInterval !== null) {
        clearInterval(searchInterval);
        searchInterval = null;
        document.getElementById("startSearchBtn").textContent = "Starta s√∂kning";
      }
      generateNewGraph();
    });
    document.getElementById("nodesSelect").addEventListener('change', () => {
      if (searchInterval !== null) {
        clearInterval(searchInterval);
        searchInterval = null;
        document.getElementById("startSearchBtn").textContent = "Starta s√∂kning";
      }
      generateNewGraph();
    });
    document.getElementById("startSearchBtn").addEventListener('click', () => {
      if (searchInterval !== null) {
        clearInterval(searchInterval);
        searchInterval = null;
        document.getElementById("startSearchBtn").textContent = "Starta s√∂kning";
        return;
      }
      graph.nodes.forEach(n => { n.visited = false; n.current = false; });
      steps = [];
      const explanation = document.getElementById("visualization").querySelector('.explanation-box');
      document.getElementById("visualization").innerHTML = explanation ? explanation.outerHTML : "";
      const algo = document.getElementById("algorithmSelect").value;
      if (algo === "dfs") {
        dfs(0);
      } else if (algo === "bfs") {
        bfs();
      } else if (algo === "iddfs") {
        const maxDepth = Math.max(...graph.nodes.map(n => n.level));
        iddfs(0, maxDepth);
      }
      animateSteps();
    });

    /*******************************************************
     * 12. Vid sidladdning: Initiera grafen med DFS som f√∂rval.
     *******************************************************/
    window.onload = () => {
      generateNewGraph();
      document.getElementById("algorithmSelect").value = "dfs";
      createExplanationAndPseudocode("dfs");
    };
    </script>
</body>

</html>