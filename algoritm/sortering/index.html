<!DOCTYPE html>
<html lang="sv">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Visualisering av sorteringsalgoritmer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400&family=Source+Serif+Pro&display=swap" />
  <style>
    :root {
      --bg: #f4f4f4;
      --white: #ffffff;
      --primary: #40534C;
      --dark: #1A3636;
      --text: #644117;
      --subtle: #D6BD98;
      --effect: #677D6A;
      --placeholder: #B9AFA1;
      --textarea: #FCF8F4;
      --extra_effect: #D98E04;
      --extra_primary: #E0A030;
      --extra_primary_dark: #705018;
      --extra_red: #A44434;
      --extra_red_dark: #52221A;
      --status_graygreen: #8E9775;
      --status_olivegreen: #5B7052;
      --status_ochreyellow: #D4A76A;
      --status_goldenbrown: #C2955C;
      --status_sienna: #A0522D;
      --status_burntumber: #8A3324;
      --status_sandbrown: #C4A484;
      --status_terracotta: #A66A4C;
      --status_bronze: #CD7F32;
      --status_cinnamon: #D2691E;
      --cell_mediumgreen: #3CB371;
      --cell_amberyellow: #ffbf00;
    }

    body {
      font-family: 'Source Serif Pro', serif;
      margin: 0;
      padding: 0;
      background-color: var(--bg);
    }

    .container {
      max-width: 700px;
      background-color: var(--white);
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin: 20px auto;
    }

    h1 {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      font-size: 24px;
      color: var(--white);
      background-color: var(--primary);
      border-radius: 8px 8px 0 0;
      padding: 10px 20px;
      box-sizing: border-box;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .inforuta {
      margin-top: 0;
      font-size: 15px;
      color: var(--text);
      background-color: var(--subtle);
      border-radius: 0 0 8px 8px;
      padding: 10px 20px;
      margin-bottom: 15px;
    }

    .controls-top {
      display: flex;
      width: 100%;
      gap: 10px;
      box-sizing: border-box;
      margin-bottom: 10px;
    }

    .controls-top > * {
      box-sizing: border-box;
    }

    #algorithmSelect {
      width: 40%;
      padding: 8px;
      background-color: var(--textarea);
      border: 1px solid var(--effect);
      color: var(--dark);
      border-radius: 5px;
    }

    #numBarsSelect {
      width: 40%;
      padding: 8px;
      background-color: var(--textarea);
      border: 1px solid var(--effect);
      color: var(--dark);
      border-radius: 5px;
    }

    #randomizeBtn {
      width: 20%;
      padding: 10px;
      background-color: var(--dark);
      color: var(--white);
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    #randomizeBtn:hover {
      background-color: var(--effect);
    }

    .visualization-wrapper {
      background-color: var(--effect);
      padding: 15px;
      border: 1px solid var(--primary);
      border-radius: 8px;
      margin: 15px 0;
    }

    #array-container {
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      height: 250px;
      border-radius: 8px;
      background-color: var(--primary);
      padding: 10px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    #array-grid {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      height: 100%;
      width: 100%;
    }

    .cell {
      background-color: var(--status_graygreen);
      border-radius: 8px;
      text-align: center;
      font-family: monospace;
      box-sizing: border-box;
      flex: 1;
      margin: 0 1px;
      position: relative;
      overflow: hidden;
      min-height: 60px;
      color: var(--white);
    }

    .cell span {
      position: absolute;
      bottom: 2px;
      left: 0;
      right: 0;
      white-space: nowrap;
      z-index: 2;
    }

    .merge-label {
      position: absolute;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      width: 14px;
      height: 14px;
      border-radius: 25%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
    }

    .merge-label.finished {
      background-color: #86ED26;
      color: var(--dark);
    }

    .merge-label.active {
      background-color: #FEDD00;
      color: var(--dark);
    }

    .controls-bottom {
      width: 100%;
      margin-top: 10px;
    }

    #startSortBtn {
      width: 100%;
      padding: 10px;
      background-color: var(--dark);
      color: var(--white);
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    #startSortBtn:hover {
      background-color: var(--effect);
    }

    @media (max-width: 600px) {
      .controls-top {
        flex-direction: column;
      }
      #algorithmSelect,
      #numBarsSelect,
      #randomizeBtn {
        width: 100%;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Visualisering av sorteringsalgoritmer</h1>
    <p class="inforuta">
      Algoritmer för sortering används här för att demonstrera hur siffror sorteras visuellt.
    </p>
    <div class="controls-top">
      <select id="algorithmSelect">
        <option value="bubble">Bubble Sort</option>
        <option value="insertion">Insertion Sort</option>
        <option value="selection">Selection Sort</option>
        <option value="merge">Merge Sort</option>
      </select>
      <select id="numBarsSelect"></select>
      <button id="randomizeBtn">Slumpa siffror</button>
    </div>
    <div class="visualization-wrapper">
      <div id="array-container">
        <div id="array-grid">
          <!-- Staplar genereras här -->
        </div>
      </div>
    </div>
    <div class="controls-bottom">
      <button id="startSortBtn">Sortera siffror i storleksordning</button>
    </div>
  </div>
  <script>
    /*******************************************************
     * Globala variabler och element
     *******************************************************/
    const algorithmSelect = document.getElementById('algorithmSelect');
    const numBarsSelect = document.getElementById('numBarsSelect');
    const randomizeBtn = document.getElementById('randomizeBtn');
    const startSortBtn = document.getElementById('startSortBtn');
    const arrayGrid = document.getElementById('array-grid');

    let array = [];
    let steps = [];
    let currentStep = 0;
    const animationDelay = 350; // ms mellan varje steg
    let comparisonsCount = 0;
    let movesCount = 0;

    let sortInterval = null;
    let isSorting = false;

    /* Förvalda startvärden (antal siffror) per algoritm */
    const defaultBars = {
      bubble: 10,
      insertion: 12,
      selection: 12,
      merge: 16
    };

    /*******************************************************
     * Avbryt pågående sortering
     *******************************************************/
    function abortSort() {
      if (sortInterval) {
        clearInterval(sortInterval);
        sortInterval = null;
      }
      isSorting = false;
      startSortBtn.textContent = "Sortera siffror i storleksordning";
      array.forEach(item => {
        item.sorted = false;
        item.mergeState = "";
      });
      renderArray(array);
    }

    /*******************************************************
     * Bygg dropdown för antalet siffror (8–32)
     *******************************************************/
    function buildNumBarsOptions() {
      numBarsSelect.innerHTML = "";
      for (let i = 8; i <= 32; i++) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = i + " siffror";
        numBarsSelect.appendChild(opt);
      }
    }
    buildNumBarsOptions();

    /*******************************************************
     * När man väljer algoritm -> sätt förval och slumpa array
     *******************************************************/
    algorithmSelect.addEventListener('change', () => {
      abortSort();
      const selectedAlgo = algorithmSelect.value;
      const defBars = defaultBars[selectedAlgo] || 10;
      numBarsSelect.value = defBars.toString();
      randomizeArray();
    });

    /*******************************************************
     * När man väljer nytt antal siffror -> slumpa omedelbart
     *******************************************************/
    numBarsSelect.addEventListener('change', () => {
      abortSort();
      randomizeArray();
    });

    /*******************************************************
     * Slumpa array baserat på dropdown-värde
     *******************************************************/
    function randomizeArray() {
      let count = parseInt(numBarsSelect.value, 10);
      if (isNaN(count) || count < 8) count = 8;
      if (count > 32) count = 32;
      array = [];
      for (let i = 0; i < count; i++) {
        const num = Math.floor(Math.random() * 90) + 10;
        array.push({ val: num, sorted: false });
      }
      comparisonsCount = 0;
      movesCount = 0;
      renderArray(array);
    }

    /*******************************************************
     * Rendera staplar i array-container
     *******************************************************/
    function renderArray(arr) {
      arrayGrid.innerHTML = "";
      const containerHeight = arrayGrid.clientHeight;
      const values = arr.map(e => e.val);
      const minValue = Math.min(...values);
      const maxValue = Math.max(...values);
      let cellMinHeight = 60;
      const tempCell = document.createElement('div');
      tempCell.className = 'cell';
      document.body.appendChild(tempCell);
      const computedStyle = getComputedStyle(tempCell);
      cellMinHeight = parseFloat(computedStyle.minHeight) || cellMinHeight;
      document.body.removeChild(tempCell);
      const cellWidth = arrayGrid.clientWidth / arr.length;
      const fontSize = Math.min(16, Math.max(8, cellWidth * 0.4));
      arr.forEach(item => {
        const cell = document.createElement('div');
        cell.className = 'cell';
        const finalHeight = calculateCellHeight(item.val, minValue, maxValue, containerHeight, cellMinHeight);
        cell.style.height = finalHeight + "px";
        let innerContent = `<span style="font-size: ${fontSize}px;">${item.val}</span>`;
        if (item.mergeState) {
          innerContent += `<div class="merge-label ${item.mergeState === "M" ? "finished" : "active"}">${item.mergeState}</div>`;
        }
        cell.innerHTML = innerContent;
        if (item.sorted) {
          cell.style.backgroundColor = "var(--cell_mediumgreen)";
        }
        arrayGrid.appendChild(cell);
      });
    }

    function calculateCellHeight(val, minValue, maxValue, containerHeight, cellMinHeight) {
      if (maxValue === minValue) {
        return containerHeight;
      }
      return cellMinHeight + ((val - minValue) / (maxValue - minValue)) * (containerHeight - cellMinHeight);
    }

    /*******************************************************
     * Inspelning av sorteringssteg för animation
     *******************************************************/
    function recordStep(arraySnapshot, indices) {
      const snapshot = JSON.parse(JSON.stringify(arraySnapshot));
      steps.push({ array: snapshot, indices });
    }

    /*******************************************************
     * Bubble Sort
     *******************************************************/
    function bubbleSort(arr) {
      let localArr = arr.slice();
      steps = [];
      const n = localArr.length;
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n - i - 1; j++) {
          recordStep(localArr, [j, j + 1]);
          if (localArr[j].val > localArr[j + 1].val) {
            const temp = localArr[j];
            localArr[j] = localArr[j + 1];
            localArr[j + 1] = temp;
            recordStep(localArr, [j, j + 1]);
          }
        }
        localArr[n - i - 1].sorted = true;
        recordStep(localArr, [n - i - 1]);
      }
      return localArr;
    }

    /*******************************************************
     * Insertion Sort
     *******************************************************/
    function insertionSort(arr) {
      let localArr = arr.slice();
      steps = [];
      for (let i = 1; i < localArr.length; i++) {
        let j = i;
        while (j > 0 && localArr[j].val < localArr[j - 1].val) {
          recordStep(localArr, [j - 1, j]);
          const temp = localArr[j];
          localArr[j] = localArr[j - 1];
          localArr[j - 1] = temp;
          recordStep(localArr, [j - 1, j]);
          j--;
        }
        for (let k = 0; k <= i; k++) {
          localArr[k].sorted = true;
        }
        recordStep(localArr, Array.from({ length: i + 1 }, (_, idx) => idx));
      }
      localArr.forEach(e => (e.sorted = true));
      recordStep(localArr, Array.from({ length: localArr.length }, (_, idx) => idx));
      return localArr;
    }

    /*******************************************************
     * Merge Sort
     *******************************************************/
    function mergeSort(arr) {
      let localArr = arr.slice();
      steps = [];
      mergeSortRecursive(localArr, 0, localArr.length - 1);
      return localArr;
    }

    function mergeSortRecursive(arr, left, right) {
      if (left < right) {
        const mid = Math.floor((left + right) / 2);
        mergeSortRecursive(arr, left, mid);
        mergeSortRecursive(arr, mid + 1, right);
        merge(arr, left, mid, right);
      }
    }

    function merge(arr, left, mid, right) {
      const L = arr.slice(left, mid + 1);
      const R = arr.slice(mid + 1, right + 1);
      for (let index = left; index <= mid; index++) {
        arr[index].mergeState = "V";
      }
      for (let index = mid + 1; index <= right; index++) {
        arr[index].mergeState = "H";
      }
      recordStep(arr, []);
      let i = 0,
        j = 0,
        k = left;
      while (i < L.length && j < R.length) {
        recordStep(arr, [k]);
        if (L[i].val <= R[j].val) {
          arr[k] = L[i];
          recordStep(arr, [k]);
          i++;
        } else {
          arr[k] = R[j];
          recordStep(arr, [k]);
          j++;
        }
        k++;
      }
      while (i < L.length) {
        arr[k] = L[i];
        recordStep(arr, [k]);
        i++;
        k++;
      }
      while (j < R.length) {
        arr[k] = R[j];
        recordStep(arr, [k]);
        j++;
        k++;
      }
      for (let index = left; index <= right; index++) {
        arr[index].mergeState = "M";
        if (left === 0 && right === arr.length - 1) {
          arr[index].sorted = true;
        }
      }
      recordStep(arr, Array.from({ length: right - left + 1 }, (_, i) => left + i));
    }

    /*******************************************************
     * Selection Sort
     *******************************************************/
    function selectionSort(arr) {
      let localArr = arr.slice();
      steps = [];
      const n = localArr.length;
      for (let i = 0; i < n; i++) {
        let minIndex = i;
        for (let j = i + 1; j < n; j++) {
          recordStep(localArr, [minIndex, j]);
          if (localArr[j].val < localArr[minIndex].val) {
            minIndex = j;
            recordStep(localArr, [minIndex]);
          }
        }
        if (minIndex !== i) {
          recordStep(localArr, [i, minIndex]);
          const temp = localArr[i];
          localArr[i] = localArr[minIndex];
          localArr[minIndex] = temp;
          recordStep(localArr, [i, minIndex]);
        }
        localArr[i].sorted = true;
        recordStep(localArr, [i]);
      }
      return localArr;
    }

    /*******************************************************
     * Animation av inspelade steg – enbart uppdatering av array-grid
     *******************************************************/
    function animateSteps() {
      currentStep = 0;
      sortInterval = setInterval(() => {
        if (currentStep >= steps.length) {
          clearInterval(sortInterval);
          sortInterval = null;
          isSorting = false;
          startSortBtn.textContent = "Sortera siffror i storleksordning";
          steps[steps.length - 1].array.forEach(e => e.sorted = true);
          updateArrayGrid(steps[steps.length - 1].array, null);
          return;
        }
        const step = steps[currentStep];
        updateArrayGrid(step.array, step.indices);
        currentStep++;
      }, animationDelay);
    }

    function updateArrayGrid(arr, highlightIndices) {
      arrayGrid.innerHTML = "";
      const containerHeight = arrayGrid.clientHeight;
      const values = arr.map(e => e.val);
      const minValue = Math.min(...values);
      const maxValue = Math.max(...values);
      let cellMinHeight = 60;
      const tempCell = document.createElement('div');
      tempCell.className = 'cell';
      document.body.appendChild(tempCell);
      const computedStyle = getComputedStyle(tempCell);
      cellMinHeight = parseFloat(computedStyle.minHeight) || cellMinHeight;
      document.body.removeChild(tempCell);
      const cellWidth = arrayGrid.clientWidth / arr.length;
      const fontSize = Math.min(16, Math.max(8, cellWidth * 0.4));
      arr.forEach((item, index) => {
        const cell = document.createElement('div');
        cell.className = 'cell';
        const finalHeight = calculateCellHeight(item.val, minValue, maxValue, containerHeight, cellMinHeight);
        cell.style.height = finalHeight + "px";
        let innerContent = `<span style="font-size: ${fontSize}px;">${item.val}</span>`;
        if (item.mergeState) {
          innerContent += `<div class="merge-label ${item.mergeState === "M" ? "finished" : "active"}">${item.mergeState}</div>`;
        }
        cell.innerHTML = innerContent;
        if (highlightIndices && highlightIndices.includes(index)) {
          cell.style.backgroundColor = "var(--cell_amberyellow)";
        } else if (item.sorted) {
          cell.style.backgroundColor = "var(--cell_mediumgreen)";
        } else {
          cell.style.backgroundColor = "var(--status_graygreen)";
        }
        arrayGrid.appendChild(cell);
      });
    }

    /*******************************************************
     * Koppla knappar
     *******************************************************/
    randomizeBtn.addEventListener('click', () => {
      abortSort();
      randomizeArray();
    });

    startSortBtn.addEventListener('click', () => {
      if (isSorting) {
        abortSort();
        return;
      }
      isSorting = true;
      startSortBtn.textContent = "Avbryt sortering";
      steps = [];
      const algo = algorithmSelect.value;
      switch (algo) {
        case "bubble":
          bubbleSort(array);
          break;
        case "insertion":
          insertionSort(array);
          break;
        case "merge":
          mergeSort(array);
          break;
        case "selection":
          selectionSort(array);
          break;
      }
      animateSteps();
    });

    /*******************************************************
     * Vid sidladdning: Initiera med Bubble Sort som standard
     *******************************************************/
    window.onload = () => {
      algorithmSelect.value = "bubble";
      algorithmSelect.dispatchEvent(new Event('change'));
    };
  </script>
</body>

</html>
